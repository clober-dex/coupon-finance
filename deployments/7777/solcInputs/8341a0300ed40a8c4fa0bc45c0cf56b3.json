{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    ) public view virtual override returns (uint256[] memory) {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner or approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(address to, uint256 id, uint256 amount, bytes memory data) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(address from, uint256[] memory ids, uint256[] memory amounts) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC1155/extensions/ERC1155Supply.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\n *\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\n * clearly identified. Note: While a totalSupply of 1 might mean the\n * corresponding is an NFT, there is no guarantees that no other token with the\n * same id are not going to be minted.\n */\nabstract contract ERC1155Supply is ERC1155 {\n    mapping(uint256 => uint256) private _totalSupply;\n\n    /**\n     * @dev Total amount of tokens in with a given id.\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    /**\n     * @dev Indicates whether any token exist with a given id, or not.\n     */\n    function exists(uint256 id) public view virtual returns (bool) {\n        return ERC1155Supply.totalSupply(id) > 0;\n    }\n\n    /**\n     * @dev See {ERC1155-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual override {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        if (from == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                _totalSupply[ids[i]] += amounts[i];\n            }\n        }\n\n        if (to == address(0)) {\n            for (uint256 i = 0; i < ids.length; ++i) {\n                uint256 id = ids[i];\n                uint256 amount = amounts[i];\n                uint256 supply = _totalSupply[id];\n                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");\n                unchecked {\n                    _totalSupply[id] = supply - amount;\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(    _domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/AaveTokenSubstitute.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {ERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {IAToken} from \"./external/aave-v3/IAToken.sol\";\nimport {IPool} from \"./external/aave-v3/IPool.sol\";\nimport {DataTypes} from \"./external/aave-v3/DataTypes.sol\";\nimport {ReserveConfiguration} from \"./external/aave-v3/ReserveConfiguration.sol\";\nimport {IAaveTokenSubstitute} from \"./interfaces/IAaveTokenSubstitute.sol\";\n\ncontract AaveTokenSubstitute is IAaveTokenSubstitute, ERC20Permit, Ownable {\n    using SafeERC20 for IERC20;\n    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;\n\n    IPool private immutable _aaveV3Pool;\n    uint8 private immutable _decimals;\n    address public immutable override aToken;\n    address public immutable override underlyingToken;\n\n    address public override treasury;\n\n    constructor(address asset_, address aaveV3Pool_, address treasury_, address owner_)\n        ERC20Permit(string.concat(\"Wrapped Aave \", IERC20Metadata(asset_).name()))\n        ERC20(\n            string.concat(\"Wrapped Aave \", IERC20Metadata(asset_).name()),\n            string.concat(\"Wa\", IERC20Metadata(asset_).symbol())\n        )\n    {\n        _aaveV3Pool = IPool(aaveV3Pool_);\n        aToken = _aaveV3Pool.getReserveData(asset_).aTokenAddress;\n        _decimals = IERC20Metadata(asset_).decimals();\n        underlyingToken = asset_;\n        treasury = treasury_;\n        _transferOwnership(owner_);\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function mintByAToken(uint256 amount, address to) external {\n        IERC20(aToken).safeTransferFrom(msg.sender, address(this), amount);\n        _mint(to, amount);\n    }\n\n    function mint(uint256 amount, address to) external {\n        IERC20(underlyingToken).safeTransferFrom(msg.sender, address(this), amount);\n        IERC20(underlyingToken).approve(address(_aaveV3Pool), amount);\n        _aaveV3Pool.supply(underlyingToken, amount, address(this), 0);\n        _mint(to, amount);\n    }\n\n    function mintableAmount() external view returns (uint256) {\n        DataTypes.ReserveConfigurationMap memory configuration =\n            _aaveV3Pool.getReserveData(underlyingToken).configuration;\n        return configuration.getSupplyCap() * 10 ** (configuration.getDecimals());\n    }\n\n    function burnToAToken(uint256 amount, address to) external {\n        _burn(msg.sender, amount);\n        IERC20(aToken).safeTransfer(address(to), amount);\n    }\n\n    function burn(uint256 amount, address to) external {\n        _burn(msg.sender, amount);\n        _aaveV3Pool.withdraw(underlyingToken, amount, to);\n    }\n\n    function burnableAmount() external view returns (uint256) {\n        return IERC20(underlyingToken).balanceOf(address(aToken));\n    }\n\n    function setTreasury(address newTreasury) external onlyOwner {\n        treasury = newTreasury;\n    }\n\n    function claim() external {\n        uint256 adminYield = IERC20(aToken).balanceOf(address(this)) - totalSupply() - 1;\n        if (adminYield > 0) {\n            IERC20(aToken).transfer(treasury, adminYield);\n        }\n    }\n}\n"
    },
    "contracts/AssetPool.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IAssetPool} from \"./interfaces/IAssetPool.sol\";\n\ncontract AssetPool is IAssetPool {\n    using SafeERC20 for IERC20;\n\n    error InvalidAccess();\n\n    mapping(address => bool) public override isOperator;\n\n    constructor(address[] memory operators) {\n        for (uint256 i = 0; i < operators.length; ++i) {\n            isOperator[operators[i]] = true;\n        }\n    }\n\n    function withdraw(address asset, uint256 amount, address recipient) external {\n        if (!isOperator[msg.sender]) {\n            revert InvalidAccess();\n        }\n        IERC20(asset).safeTransfer(recipient, amount);\n    }\n}\n"
    },
    "contracts/BondPositionManager.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport {IBondPositionManager} from \"./interfaces/IBondPositionManager.sol\";\nimport {ICouponManager} from \"./interfaces/ICouponManager.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IAssetPool} from \"./interfaces/IAssetPool.sol\";\nimport {IBondPositionCallbackReceiver} from \"./interfaces/IBondPositionCallbackReceiver.sol\";\nimport {ERC721Permit} from \"./libraries/ERC721Permit.sol\";\nimport {BondPosition, BondPositionLibrary} from \"./libraries/BondPosition.sol\";\nimport {Coupon, CouponLibrary} from \"./libraries/Coupon.sol\";\nimport {Epoch, EpochLibrary} from \"./libraries/Epoch.sol\";\nimport {PositionManager} from \"./libraries/PositionManager.sol\";\n\ncontract BondPositionManager is IBondPositionManager, PositionManager, Ownable {\n    using SafeERC20 for IERC20;\n    using Strings for uint256;\n    using EpochLibrary for Epoch;\n    using BondPositionLibrary for BondPosition;\n    using CouponLibrary for Coupon;\n\n    Epoch private constant _MAX_EPOCH = Epoch.wrap(157); // Ends at 31 Dec 2048 23:59:59 GMT\n\n    mapping(address asset => bool) public override isAssetRegistered;\n    mapping(uint256 id => BondPosition) private _positionMap;\n\n    constructor(address coupon_, address assetPool_, string memory baseURI_)\n        PositionManager(coupon_, assetPool_, baseURI_, \"Bond Position\", \"BP\")\n    {}\n\n    function getMaxEpoch() external pure returns (Epoch maxEpoch) {\n        return _MAX_EPOCH;\n    }\n\n    function getPosition(uint256 positionId) external view returns (BondPosition memory) {\n        return _positionMap[positionId];\n    }\n\n    function mint(address asset) external onlyByLocker returns (uint256 positionId) {\n        if (!isAssetRegistered[asset]) {\n            revert UnregisteredAsset();\n        }\n\n        unchecked {\n            positionId = nextId++;\n        }\n        _positionMap[positionId].asset = asset;\n        _mint(msg.sender, positionId);\n    }\n\n    function adjustPosition(uint256 positionId, uint256 amount, Epoch expiredWith)\n        external\n        onlyByLocker\n        modifyPosition(positionId)\n        returns (Coupon[] memory couponsToMint, Coupon[] memory couponsToBurn, int256 amountDelta)\n    {\n        if (!_isApprovedOrOwner(msg.sender, positionId)) {\n            revert InvalidAccess();\n        }\n        Epoch lastExpiredEpoch = EpochLibrary.lastExpiredEpoch();\n        if (amount == 0 || expiredWith == Epoch.wrap(0)) {\n            amount = 0;\n            expiredWith = lastExpiredEpoch;\n        }\n\n        if (expiredWith < lastExpiredEpoch || _MAX_EPOCH < expiredWith) {\n            revert InvalidEpoch();\n        }\n\n        BondPosition memory position = _positionMap[positionId];\n\n        _positionMap[positionId].amount = amount;\n        if (Epoch.wrap(0) < position.expiredWith && position.expiredWith <= lastExpiredEpoch) {\n            if (amount > 0) revert AlreadyExpired();\n        } else {\n            _positionMap[positionId].expiredWith = expiredWith;\n            if (position.expiredWith == Epoch.wrap(0)) {\n                position.expiredWith = lastExpiredEpoch;\n            }\n\n            (couponsToMint, couponsToBurn) = position.calculateCouponRequirement(_positionMap[positionId]);\n        }\n\n        for (uint256 i = 0; i < couponsToMint.length; ++i) {\n            _accountDelta(couponsToMint[i].id(), 0, couponsToMint[i].amount);\n        }\n        for (uint256 i = 0; i < couponsToBurn.length; ++i) {\n            _accountDelta(couponsToBurn[i].id(), couponsToBurn[i].amount, 0);\n        }\n        amountDelta = _accountDelta(uint256(uint160(position.asset)), amount, position.amount);\n    }\n\n    function settlePosition(uint256 positionId) public override(IPositionManager, PositionManager) onlyByLocker {\n        super.settlePosition(positionId);\n        BondPosition memory position = _positionMap[positionId];\n        if (_MAX_EPOCH < position.expiredWith) {\n            revert InvalidEpoch();\n        }\n        if (position.amount == 0) {\n            _burn(positionId);\n        } else {\n            if (position.expiredWith < EpochLibrary.current()) {\n                revert InvalidEpoch();\n            }\n        }\n        emit PositionUpdated(positionId, position.amount, position.expiredWith);\n    }\n\n    function registerAsset(address asset) external onlyOwner {\n        _registerAsset(asset);\n    }\n\n    function nonces(uint256 positionId) external view returns (uint256) {\n        return _positionMap[positionId].nonce;\n    }\n\n    function _registerAsset(address asset) internal {\n        isAssetRegistered[asset] = true;\n        emit AssetRegistered(asset);\n    }\n\n    function _getAndIncrementNonce(uint256 positionId) internal override returns (uint256) {\n        return _positionMap[positionId].getAndIncrementNonce();\n    }\n\n    function _isSettled(uint256 positionId) internal view override returns (bool) {\n        return _positionMap[positionId].isSettled;\n    }\n\n    function _setPositionSettlement(uint256 positionId, bool settled) internal override {\n        _positionMap[positionId].isSettled = settled;\n    }\n}\n"
    },
    "contracts/BorrowController.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IWETH9} from \"./external/weth/IWETH9.sol\";\nimport {IERC721Permit} from \"./interfaces/IERC721Permit.sol\";\nimport {ISubstitute} from \"./interfaces/ISubstitute.sol\";\nimport {IBorrowController} from \"./interfaces/IBorrowController.sol\";\nimport {ILoanPositionManager} from \"./interfaces/ILoanPositionManager.sol\";\nimport {LoanPosition, LoanPositionLibrary} from \"./libraries/LoanPosition.sol\";\nimport {CouponKey, CouponKeyLibrary} from \"./libraries/CouponKey.sol\";\nimport {Coupon} from \"./libraries/Coupon.sol\";\nimport {Epoch, EpochLibrary} from \"./libraries/Epoch.sol\";\nimport {PermitParams} from \"./libraries/PermitParams.sol\";\nimport {Controller} from \"./libraries/Controller.sol\";\nimport {IPositionLocker} from \"./interfaces/IPositionLocker.sol\";\n\ncontract BorrowController is IBorrowController, Controller, IPositionLocker {\n    using SafeERC20 for IERC20;\n    using LoanPositionLibrary for LoanPosition;\n    using CouponKeyLibrary for CouponKey;\n    using EpochLibrary for Epoch;\n\n    ILoanPositionManager private immutable _loanManager;\n\n    modifier onlyPositionOwner(uint256 positionId) {\n        if (_loanManager.ownerOf(positionId) != msg.sender) {\n            revert InvalidAccess();\n        }\n        _;\n    }\n\n    constructor(\n        address wrapped1155Factory,\n        address cloberMarketFactory,\n        address couponManager,\n        address weth,\n        address loanManager\n    ) Controller(wrapped1155Factory, cloberMarketFactory, couponManager, weth) {\n        _loanManager = ILoanPositionManager(loanManager);\n    }\n\n    function positionLockAcquired(bytes memory data) external returns (bytes memory result) {\n        if (msg.sender != address(_loanManager)) revert InvalidAccess();\n\n        uint256 positionId;\n        address user;\n        (positionId, user, data) = abi.decode(data, (uint256, address, bytes));\n        if (positionId == 0) {\n            address collateralToken;\n            address debtToken;\n            (collateralToken, debtToken, data) = abi.decode(data, (address, address, bytes));\n            positionId = _loanManager.mint(collateralToken, debtToken);\n            result = abi.encode(positionId);\n        }\n        LoanPosition memory position = _loanManager.getPosition(positionId);\n\n        uint256 maxPayInterest;\n        uint256 minEarnInterest;\n        bytes memory swapData;\n        (\n            position.collateralAmount,\n            position.debtAmount,\n            position.expiredWith,\n            maxPayInterest,\n            minEarnInterest,\n            swapData\n        ) = abi.decode(data, (uint256, uint256, Epoch, uint256, uint256, bytes));\n\n        (Coupon[] memory couponsToPay, Coupon[] memory couponsToRefund, int256 collateralDelta, int256 debtDelta) =\n        _loanManager.adjustPosition(positionId, position.collateralAmount, position.debtAmount, position.expiredWith);\n        if (collateralDelta < 0) {\n            _loanManager.withdrawToken(position.collateralToken, address(this), uint256(-collateralDelta));\n        }\n        if (debtDelta > 0) {\n            _loanManager.withdrawToken(position.debtToken, address(this), uint256(debtDelta));\n        }\n        if (couponsToRefund.length > 0) {\n            _loanManager.mintCoupons(couponsToRefund, address(this), new bytes(0));\n            _wrapCoupons(couponsToRefund);\n        }\n\n        if (swapData.length > 0) {\n            _swapCollateral(abi.decode(swapData, (SwapData)), position.collateralToken, position.debtToken);\n        }\n\n        _executeCouponTrade(\n            user,\n            position.debtToken,\n            couponsToPay,\n            couponsToRefund,\n            debtDelta < 0 ? uint256(-debtDelta) : 0,\n            maxPayInterest,\n            minEarnInterest\n        );\n\n        if (collateralDelta > 0) {\n            _ensureBalance(position.collateralToken, user, uint256(collateralDelta));\n            _loanManager.depositToken(position.collateralToken, uint256(collateralDelta));\n        }\n        if (debtDelta < 0) {\n            _loanManager.depositToken(position.debtToken, uint256(-debtDelta));\n        }\n        if (couponsToPay.length > 0) {\n            _unwrapCoupons(couponsToPay);\n            _loanManager.burnCoupons(couponsToPay);\n        }\n        if (swapData.length > 0) {\n            uint256 leftDebtToken = IERC20(position.debtToken).balanceOf(address(this));\n            if (leftDebtToken > 0) {\n                position = _loanManager.getPosition(positionId);\n                (, Coupon[] memory leftCoupons,,) = _loanManager.adjustPosition(\n                    positionId,\n                    position.collateralAmount,\n                    position.debtAmount > leftDebtToken ? position.debtAmount - leftDebtToken : 0,\n                    position.expiredWith\n                );\n                _loanManager.depositToken(position.debtToken, leftDebtToken);\n                _loanManager.mintCoupons(leftCoupons, user, \"\");\n            }\n        }\n\n        _loanManager.settlePosition(positionId);\n    }\n\n    function borrow(\n        address collateralToken,\n        address debtToken,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        uint256 maxPayInterest,\n        uint8 loanEpochs,\n        PermitParams calldata collateralPermitParams\n    ) external payable nonReentrant wrapETH {\n        _permitERC20(collateralToken, collateralAmount, collateralPermitParams);\n\n        bytes memory lockData = abi.encode(\n            0,\n            msg.sender,\n            abi.encode(\n                collateralToken,\n                debtToken,\n                abi.encode(\n                    collateralAmount, borrowAmount, EpochLibrary.current().add(loanEpochs - 1), maxPayInterest, 0, \"\"\n                )\n            )\n        );\n        uint256 positionId = abi.decode(_loanManager.lock(lockData), (uint256));\n\n        _burnAllSubstitute(collateralToken, msg.sender);\n        _burnAllSubstitute(debtToken, msg.sender);\n        _loanManager.transferFrom(address(this), msg.sender, positionId);\n    }\n\n    function borrowMore(\n        uint256 positionId,\n        uint256 amount,\n        uint256 maxPayInterest,\n        PermitParams calldata positionPermitParams\n    ) external nonReentrant onlyPositionOwner(positionId) {\n        _permitERC721(_loanManager, positionId, positionPermitParams);\n        LoanPosition memory position = _loanManager.getPosition(positionId);\n        position.debtAmount += amount;\n        _loanManager.lock(_encodeLockData(positionId, position, maxPayInterest, 0, \"\"));\n        _burnAllSubstitute(position.debtToken, msg.sender);\n    }\n\n    function addCollateral(\n        uint256 positionId,\n        uint256 amount,\n        PermitParams calldata positionPermitParams,\n        PermitParams calldata collateralPermitParams\n    ) external payable nonReentrant onlyPositionOwner(positionId) wrapETH {\n        _permitERC721(_loanManager, positionId, positionPermitParams);\n        LoanPosition memory position = _loanManager.getPosition(positionId);\n        _permitERC20(position.collateralToken, amount, collateralPermitParams);\n        position.collateralAmount += amount;\n        _loanManager.lock(_encodeLockData(positionId, position, 0, 0, \"\"));\n    }\n\n    function removeCollateral(uint256 positionId, uint256 amount, PermitParams calldata positionPermitParams)\n        external\n        nonReentrant\n        onlyPositionOwner(positionId)\n    {\n        _permitERC721(_loanManager, positionId, positionPermitParams);\n        LoanPosition memory position = _loanManager.getPosition(positionId);\n        position.collateralAmount -= amount;\n        _loanManager.lock(_encodeLockData(positionId, position, 0, 0, \"\"));\n        _burnAllSubstitute(position.collateralToken, msg.sender);\n    }\n\n    function extendLoanDuration(\n        uint256 positionId,\n        uint8 epochs,\n        uint256 maxPayInterest,\n        PermitParams calldata positionPermitParams,\n        PermitParams calldata debtPermitParams\n    ) external payable nonReentrant onlyPositionOwner(positionId) wrapETH {\n        _permitERC721(_loanManager, positionId, positionPermitParams);\n        LoanPosition memory position = _loanManager.getPosition(positionId);\n        _permitERC20(position.collateralToken, maxPayInterest, debtPermitParams);\n        position.expiredWith = position.expiredWith.add(epochs);\n        _loanManager.lock(_encodeLockData(positionId, position, maxPayInterest, 0, \"\"));\n        _burnAllSubstitute(position.debtToken, msg.sender);\n    }\n\n    function shortenLoanDuration(\n        uint256 positionId,\n        uint8 epochs,\n        uint256 minEarnInterest,\n        PermitParams calldata positionPermitParams\n    ) external nonReentrant onlyPositionOwner(positionId) {\n        _permitERC721(_loanManager, positionId, positionPermitParams);\n        LoanPosition memory position = _loanManager.getPosition(positionId);\n        position.expiredWith = position.expiredWith.sub(epochs);\n        _loanManager.lock(_encodeLockData(positionId, position, 0, minEarnInterest, \"\"));\n        _burnAllSubstitute(position.debtToken, msg.sender);\n    }\n\n    function repay(\n        uint256 positionId,\n        uint256 amount,\n        uint256 minEarnInterest,\n        PermitParams calldata positionPermitParams,\n        PermitParams calldata debtPermitParams\n    ) external payable nonReentrant onlyPositionOwner(positionId) wrapETH {\n        _permitERC721(_loanManager, positionId, positionPermitParams);\n        LoanPosition memory position = _loanManager.getPosition(positionId);\n        _permitERC20(position.debtToken, amount, debtPermitParams);\n        position.debtAmount -= amount;\n        _loanManager.lock(_encodeLockData(positionId, position, 0, minEarnInterest, \"\"));\n        _burnAllSubstitute(position.debtToken, msg.sender);\n    }\n\n    function repayWithCollateral(\n        uint256 positionId,\n        uint256 maxDebtAmount,\n        SwapData calldata swapData,\n        PermitParams calldata positionPermitParams\n    ) external nonReentrant onlyPositionOwner(positionId) {\n        _permitERC721(_loanManager, positionId, positionPermitParams);\n        LoanPosition memory position = _loanManager.getPosition(positionId);\n\n        if (maxDebtAmount >= position.debtAmount) revert InvalidDebtAmount();\n        position.collateralAmount -= swapData.inAmount;\n        position.debtAmount = maxDebtAmount;\n        _loanManager.lock(_encodeLockData(positionId, position, type(uint256).max, 0, abi.encode(swapData)));\n    }\n\n    function _swapCollateral(SwapData memory swapData, address inToken, address outToken) internal {\n        ISubstitute(inToken).burn(swapData.inAmount, address(this));\n        IERC20(ISubstitute(inToken).underlyingToken()).approve(swapData.swap, swapData.inAmount);\n\n        address outTokenUnderlying = ISubstitute(outToken).underlyingToken();\n        uint256 beforeBalance = IERC20(outTokenUnderlying).balanceOf(address(this));\n\n        (bool success, bytes memory result) = swapData.swap.call(swapData.data);\n        if (!success) revert CollateralSwapFailed(string(result));\n\n        uint256 diffBalance = IERC20(outTokenUnderlying).balanceOf(address(this)) - beforeBalance;\n        if (swapData.minOutAmount > diffBalance) revert ControllerSlippage();\n\n        IERC20(outTokenUnderlying).approve(outToken, diffBalance);\n        ISubstitute(outToken).mint(diffBalance, address(this));\n    }\n\n    function _encodeLockData(uint256 id, LoanPosition memory p, uint256 maxPay, uint256 minEarn, bytes memory swapData)\n        internal\n        view\n        returns (bytes memory)\n    {\n        bytes memory data = abi.encode(p.collateralAmount, p.debtAmount, p.expiredWith, maxPay, minEarn, swapData);\n        return abi.encode(id, msg.sender, data);\n    }\n\n    function setCollateralAllowance(address collateralToken) external onlyOwner {\n        IERC20(collateralToken).approve(address(_loanManager), type(uint256).max);\n    }\n}\n"
    },
    "contracts/CouponManager.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport {ERC1155Supply} from \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport {CouponKey, CouponKeyLibrary} from \"./libraries/CouponKey.sol\";\nimport {Coupon, CouponLibrary} from \"./libraries/Coupon.sol\";\nimport {Epoch, EpochLibrary} from \"./libraries/Epoch.sol\";\nimport {ERC1155Permit} from \"./libraries/ERC1155Permit.sol\";\nimport {ICouponManager} from \"./interfaces/ICouponManager.sol\";\n\ncontract CouponManager is ERC1155Permit, ERC1155Supply, ICouponManager {\n    using Strings for uint256;\n    using CouponKeyLibrary for CouponKey;\n    using CouponLibrary for Coupon;\n    using EpochLibrary for Epoch;\n\n    mapping(address => bool) public override isMinter;\n    string public override baseURI;\n\n    constructor(address[] memory minters, string memory uri_) ERC1155Permit(uri_, \"Coupon\", \"1\") {\n        for (uint256 i = 0; i < minters.length; ++i) {\n            isMinter[minters[i]] = true;\n        }\n        baseURI = uri_;\n    }\n\n    modifier onlyMinter() {\n        if (!isMinter[msg.sender]) {\n            revert InvalidAccess();\n        }\n        _;\n    }\n\n    // View Functions //\n    function uri(uint256 id) public view override(ERC1155, IERC1155MetadataURI) returns (string memory) {\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, id.toHexString(32))) : \"\";\n    }\n\n    function currentEpoch() external view returns (Epoch) {\n        return EpochLibrary.current();\n    }\n\n    function epochEndTime(Epoch epoch) external pure returns (uint256) {\n        return epoch.endTime();\n    }\n\n    function totalSupply(uint256 id) public view override(ERC1155Supply, ICouponManager) returns (uint256) {\n        return super.totalSupply(id);\n    }\n\n    function exists(uint256 id) public view override(ERC1155Supply, ICouponManager) returns (bool) {\n        return super.exists(id);\n    }\n\n    // User Functions\n    function safeBatchTransferFrom(address from, address to, Coupon[] calldata coupons, bytes calldata data) external {\n        (uint256[] memory ids, uint256[] memory amounts) = _splitCoupons(coupons);\n        safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    function burnExpiredCoupons(CouponKey[] calldata couponKeys) external {\n        uint256[] memory ids = new uint256[](couponKeys.length);\n        uint256[] memory amounts = new uint256[](couponKeys.length);\n        Epoch current = EpochLibrary.current();\n        uint256 count;\n        for (uint256 i = 0; i < couponKeys.length; ++i) {\n            if (couponKeys[i].epoch >= current) {\n                continue;\n            }\n            uint256 id = couponKeys[i].toId();\n            uint256 amount = balanceOf(msg.sender, id);\n            if (amount == 0) {\n                continue;\n            }\n            count++;\n            ids[i] = id;\n            amounts[i] = amount;\n        }\n        assembly {\n            mstore(ids, count)\n            mstore(amounts, count)\n        }\n        _burnBatch(msg.sender, ids, amounts);\n    }\n\n    // Admin Functions //\n    function mintBatch(address to, Coupon[] calldata coupons, bytes memory data) external onlyMinter {\n        (uint256[] memory ids, uint256[] memory amounts) = _splitCoupons(coupons);\n        _mintBatch(to, ids, amounts, data);\n    }\n\n    function burnBatch(address user, Coupon[] calldata coupons) external onlyMinter {\n        (uint256[] memory ids, uint256[] memory amounts) = _splitCoupons(coupons);\n        _burnBatch(user, ids, amounts);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155, ERC1155Permit, IERC165)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal override(ERC1155, ERC1155Supply) {\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n    }\n\n    function _splitCoupons(Coupon[] calldata coupons)\n        internal\n        pure\n        returns (uint256[] memory ids, uint256[] memory amounts)\n    {\n        ids = new uint256[](coupons.length);\n        amounts = new uint256[](coupons.length);\n        unchecked {\n            for (uint256 i = 0; i < coupons.length; ++i) {\n                ids[i] = coupons[i].key.toId();\n                amounts[i] = coupons[i].amount;\n            }\n        }\n    }\n}\n"
    },
    "contracts/CouponOracle.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {AggregatorV3Interface} from \"./external/chainlink/AggregatorV3Interface.sol\";\nimport {ICouponOracle} from \"./interfaces/ICouponOracle.sol\";\nimport {IFallbackOracle} from \"./interfaces/IFallbackOracle.sol\";\n\ncontract CouponOracle is ICouponOracle, Ownable {\n    address public override fallbackOracle;\n    mapping(address => address) private _assetFeedMap;\n\n    constructor(address[] memory assets, address[] memory feeds) {\n        _setFeeds(assets, feeds);\n    }\n\n    function decimals() external pure returns (uint8) {\n        return 8;\n    }\n\n    function getFeed(address asset) external view returns (address) {\n        return _assetFeedMap[asset];\n    }\n\n    function getAssetPrice(address asset) public view returns (uint256) {\n        address feed = _assetFeedMap[asset];\n\n        if (feed != address(0)) {\n            (, int256 price,,,) = AggregatorV3Interface(feed).latestRoundData();\n            if (price > 0) {\n                return uint256(price);\n            }\n        }\n        return _fallback(asset);\n    }\n\n    function _fallback(address asset) internal view returns (uint256) {\n        return IFallbackOracle(fallbackOracle).getAssetPrice(asset);\n    }\n\n    function getAssetsPrices(address[] memory assets) external view returns (uint256[] memory prices) {\n        prices = new uint256[](assets.length);\n        unchecked {\n            for (uint256 i = 0; i < assets.length; ++i) {\n                prices[i] = getAssetPrice(assets[i]);\n            }\n        }\n    }\n\n    function setFallbackOracle(address newFallbackOracle) external onlyOwner {\n        fallbackOracle = newFallbackOracle;\n    }\n\n    function setFeeds(address[] memory assets, address[] memory feeds) external onlyOwner {\n        _setFeeds(assets, feeds);\n    }\n\n    function _setFeeds(address[] memory assets, address[] memory feeds) internal {\n        if (assets.length != feeds.length) revert LengthMismatch();\n        unchecked {\n            for (uint256 i = 0; i < assets.length; ++i) {\n                if (AggregatorV3Interface(feeds[i]).decimals() != 8) revert InvalidDecimals();\n                _assetFeedMap[assets[i]] = feeds[i];\n            }\n        }\n    }\n}\n"
    },
    "contracts/DepositController.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {IWETH9} from \"./external/weth/IWETH9.sol\";\nimport {IERC721Permit} from \"./interfaces/IERC721Permit.sol\";\nimport {IDepositController} from \"./interfaces/IDepositController.sol\";\nimport {IBondPositionManager} from \"./interfaces/IBondPositionManager.sol\";\nimport {IPositionLocker} from \"./interfaces/IPositionLocker.sol\";\nimport {BondPosition, BondPositionLibrary} from \"./libraries/BondPosition.sol\";\nimport {Epoch, EpochLibrary} from \"./libraries/Epoch.sol\";\nimport {CouponKey, CouponKeyLibrary} from \"./libraries/CouponKey.sol\";\nimport {Coupon, CouponLibrary} from \"./libraries/Coupon.sol\";\nimport {PermitParams} from \"./libraries/PermitParams.sol\";\nimport {Controller} from \"./libraries/Controller.sol\";\nimport {Wrapped1155MetadataBuilder} from \"./libraries/Wrapped1155MetadataBuilder.sol\";\n\ncontract DepositController is IDepositController, Controller, IPositionLocker {\n    using SafeERC20 for IERC20;\n    using BondPositionLibrary for BondPosition;\n    using EpochLibrary for Epoch;\n    using CouponKeyLibrary for CouponKey;\n    using CouponLibrary for Coupon;\n\n    IBondPositionManager private immutable _bondManager;\n\n    modifier onlyPositionOwner(uint256 positionId) {\n        if (_bondManager.ownerOf(positionId) != msg.sender) {\n            revert InvalidAccess();\n        }\n        _;\n    }\n\n    constructor(\n        address wrapped1155Factory,\n        address cloberMarketFactory,\n        address couponManager,\n        address weth,\n        address bondManager\n    ) Controller(wrapped1155Factory, cloberMarketFactory, couponManager, weth) {\n        _bondManager = IBondPositionManager(bondManager);\n    }\n\n    function positionLockAcquired(bytes memory data) external returns (bytes memory result) {\n        if (msg.sender != address(_bondManager)) revert InvalidAccess();\n\n        uint256 positionId;\n        address user;\n        (positionId, user, data) = abi.decode(data, (uint256, address, bytes));\n        if (positionId == 0) {\n            address asset;\n            (asset, data) = abi.decode(data, (address, bytes));\n            positionId = _bondManager.mint(asset);\n            result = abi.encode(positionId);\n        }\n        BondPosition memory position = _bondManager.getPosition(positionId);\n\n        uint256 maxPayInterest;\n        uint256 minEarnInterest;\n        (position.amount, position.expiredWith, maxPayInterest, minEarnInterest) =\n            abi.decode(data, (uint256, Epoch, uint256, uint256));\n        (Coupon[] memory couponsToMint, Coupon[] memory couponsToBurn, int256 amountDelta) =\n            _bondManager.adjustPosition(positionId, position.amount, position.expiredWith);\n        if (amountDelta < 0) {\n            _bondManager.withdrawToken(position.asset, address(this), uint256(-amountDelta));\n        }\n        if (couponsToMint.length > 0) {\n            _bondManager.mintCoupons(couponsToMint, address(this), new bytes(0));\n            _wrapCoupons(couponsToMint);\n        }\n\n        _executeCouponTrade(\n            user,\n            position.asset,\n            couponsToBurn,\n            couponsToMint,\n            amountDelta > 0 ? uint256(amountDelta) : 0,\n            maxPayInterest,\n            minEarnInterest\n        );\n\n        if (amountDelta > 0) {\n            _bondManager.depositToken(position.asset, uint256(amountDelta));\n        }\n        if (couponsToBurn.length > 0) {\n            _unwrapCoupons(couponsToBurn);\n            _bondManager.burnCoupons(couponsToBurn);\n        }\n\n        _bondManager.settlePosition(positionId);\n    }\n\n    function deposit(\n        address asset,\n        uint256 amount,\n        uint8 lockEpochs,\n        uint256 minEarnInterest,\n        PermitParams calldata tokenPermitParams\n    ) external payable nonReentrant wrapETH {\n        _permitERC20(asset, amount, tokenPermitParams);\n\n        bytes memory lockData = abi.encode(\n            0,\n            msg.sender,\n            abi.encode(asset, abi.encode(amount, EpochLibrary.current().add(lockEpochs - 1), 0, minEarnInterest))\n        );\n        uint256 positionId = abi.decode(_bondManager.lock(lockData), (uint256));\n\n        _burnAllSubstitute(asset, msg.sender);\n        _bondManager.transferFrom(address(this), msg.sender, positionId);\n    }\n\n    function withdraw(\n        uint256 positionId,\n        uint256 withdrawAmount,\n        uint256 maxPayInterest,\n        PermitParams calldata positionPermitParams\n    ) external nonReentrant onlyPositionOwner(positionId) {\n        _permitERC721(IERC721Permit(_bondManager), positionId, positionPermitParams);\n        BondPosition memory position = _bondManager.getPosition(positionId);\n\n        _bondManager.lock(\n            abi.encode(\n                positionId,\n                msg.sender,\n                abi.encode(position.amount - withdrawAmount, position.expiredWith, maxPayInterest, 0)\n            )\n        );\n\n        _burnAllSubstitute(position.asset, msg.sender);\n    }\n\n    function collect(uint256 positionId, PermitParams calldata positionPermitParams)\n        external\n        nonReentrant\n        onlyPositionOwner(positionId)\n    {\n        _permitERC721(IERC721Permit(_bondManager), positionId, positionPermitParams);\n        BondPosition memory position = _bondManager.getPosition(positionId);\n        _bondManager.lock(abi.encode(positionId, msg.sender, abi.encode(0, position.expiredWith, 0, 0)));\n        _burnAllSubstitute(position.asset, msg.sender);\n    }\n\n    function setCouponMarket(CouponKey memory couponKey, address cloberMarket) public override onlyOwner {\n        IERC20(couponKey.asset).approve(address(_bondManager), type(uint256).max);\n        super.setCouponMarket(couponKey, cloberMarket);\n    }\n}\n"
    },
    "contracts/external/aave-v3/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        //timestamp of last update\n        uint40 lastUpdateTimestamp;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint16 id;\n        //aToken address\n        address aTokenAddress;\n        //stableDebtToken address\n        address stableDebtTokenAddress;\n        //variableDebtToken address\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the current treasury balance, scaled\n        uint128 accruedToTreasury;\n        //the outstanding unbacked aTokens minted through the bridging feature\n        uint128 unbacked;\n        //the outstanding debt borrowed against this asset in isolation mode\n        uint128 isolationModeTotalDebt;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60: asset is paused\n        //bit 61: borrowing in isolation mode is enabled\n        //bit 62: siloed borrowing enabled\n        //bit 63: flashloaning enabled\n        //bit 64-79: reserve factor\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n        //bit 152-167 liquidation protocol fee\n        //bit 168-175 eMode category\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n        //bit 252-255 unused\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        /**\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\n         * asset is borrowed by the user.\n         */\n        uint256 data;\n    }\n\n    struct EModeCategory {\n        // each eMode category has a custom ltv and liquidation threshold\n        uint16 ltv;\n        uint16 liquidationThreshold;\n        uint16 liquidationBonus;\n        // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n        address priceSource;\n        string label;\n    }\n\n    enum InterestRateMode {\n        NONE,\n        STABLE,\n        VARIABLE\n    }\n\n    struct ReserveCache {\n        uint256 currScaledVariableDebt;\n        uint256 nextScaledVariableDebt;\n        uint256 currPrincipalStableDebt;\n        uint256 currAvgStableBorrowRate;\n        uint256 currTotalStableDebt;\n        uint256 nextAvgStableBorrowRate;\n        uint256 nextTotalStableDebt;\n        uint256 currLiquidityIndex;\n        uint256 nextLiquidityIndex;\n        uint256 currVariableBorrowIndex;\n        uint256 nextVariableBorrowIndex;\n        uint256 currLiquidityRate;\n        uint256 currVariableBorrowRate;\n        uint256 reserveFactor;\n        ReserveConfigurationMap reserveConfiguration;\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        uint40 reserveLastUpdateTimestamp;\n        uint40 stableDebtLastUpdateTimestamp;\n    }\n\n    struct ExecuteLiquidationCallParams {\n        uint256 reservesCount;\n        uint256 debtToCover;\n        address collateralAsset;\n        address debtAsset;\n        address user;\n        bool receiveAToken;\n        address priceOracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteSupplyParams {\n        address asset;\n        uint256 amount;\n        address onBehalfOf;\n        uint16 referralCode;\n    }\n\n    struct ExecuteBorrowParams {\n        address asset;\n        address user;\n        address onBehalfOf;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        uint16 referralCode;\n        bool releaseUnderlying;\n        uint256 maxStableRateBorrowSizePercent;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n    }\n\n    struct ExecuteRepayParams {\n        address asset;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        address onBehalfOf;\n        bool useATokens;\n    }\n\n    struct ExecuteWithdrawParams {\n        address asset;\n        uint256 amount;\n        address to;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n    }\n\n    struct ExecuteSetUserEModeParams {\n        uint256 reservesCount;\n        address oracle;\n        uint8 categoryId;\n    }\n\n    struct FinalizeTransferParams {\n        address asset;\n        address from;\n        address to;\n        uint256 amount;\n        uint256 balanceFromBefore;\n        uint256 balanceToBefore;\n        uint256 reservesCount;\n        address oracle;\n        uint8 fromEModeCategory;\n    }\n\n    struct FlashloanParams {\n        address receiverAddress;\n        address[] assets;\n        uint256[] amounts;\n        uint256[] interestRateModes;\n        address onBehalfOf;\n        bytes params;\n        uint16 referralCode;\n        uint256 flashLoanPremiumToProtocol;\n        uint256 flashLoanPremiumTotal;\n        uint256 maxStableRateBorrowSizePercent;\n        uint256 reservesCount;\n        address addressesProvider;\n        uint8 userEModeCategory;\n        bool isAuthorizedFlashBorrower;\n    }\n\n    struct FlashloanSimpleParams {\n        address receiverAddress;\n        address asset;\n        uint256 amount;\n        bytes params;\n        uint16 referralCode;\n        uint256 flashLoanPremiumToProtocol;\n        uint256 flashLoanPremiumTotal;\n    }\n\n    struct FlashLoanRepaymentParams {\n        uint256 amount;\n        uint256 totalPremium;\n        uint256 flashLoanPremiumToProtocol;\n        address asset;\n        address receiverAddress;\n        uint16 referralCode;\n    }\n\n    struct CalculateUserAccountDataParams {\n        UserConfigurationMap userConfig;\n        uint256 reservesCount;\n        address user;\n        address oracle;\n        uint8 userEModeCategory;\n    }\n\n    struct ValidateBorrowParams {\n        ReserveCache reserveCache;\n        UserConfigurationMap userConfig;\n        address asset;\n        address userAddress;\n        uint256 amount;\n        InterestRateMode interestRateMode;\n        uint256 maxStableLoanPercent;\n        uint256 reservesCount;\n        address oracle;\n        uint8 userEModeCategory;\n        address priceOracleSentinel;\n        bool isolationModeActive;\n        address isolationModeCollateralAddress;\n        uint256 isolationModeDebtCeiling;\n    }\n\n    struct ValidateLiquidationCallParams {\n        ReserveCache debtReserveCache;\n        uint256 totalDebt;\n        uint256 healthFactor;\n        address priceOracleSentinel;\n    }\n\n    struct CalculateInterestRatesParams {\n        uint256 unbacked;\n        uint256 liquidityAdded;\n        uint256 liquidityTaken;\n        uint256 totalStableDebt;\n        uint256 totalVariableDebt;\n        uint256 averageStableBorrowRate;\n        uint256 reserveFactor;\n        address reserve;\n        address aToken;\n    }\n\n    struct InitReserveParams {\n        address asset;\n        address aTokenAddress;\n        address stableDebtAddress;\n        address variableDebtAddress;\n        address interestRateStrategyAddress;\n        uint16 reservesCount;\n        uint16 maxNumberReserves;\n    }\n}\n"
    },
    "contracts/external/aave-v3/Errors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n */\nlibrary Errors {\n    string public constant CALLER_NOT_POOL_ADMIN = \"1\"; // 'The caller of the function is not a pool admin'\n    string public constant CALLER_NOT_EMERGENCY_ADMIN = \"2\"; // 'The caller of the function is not an emergency admin'\n    string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = \"3\"; // 'The caller of the function is not a pool or emergency admin'\n    string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = \"4\"; // 'The caller of the function is not a risk or pool admin'\n    string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = \"5\"; // 'The caller of the function is not an asset listing or pool admin'\n    string public constant CALLER_NOT_BRIDGE = \"6\"; // 'The caller of the function is not a bridge'\n    string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = \"7\"; // 'Pool addresses provider is not registered'\n    string public constant INVALID_ADDRESSES_PROVIDER_ID = \"8\"; // 'Invalid id for the pool addresses provider'\n    string public constant NOT_CONTRACT = \"9\"; // 'Address is not a contract'\n    string public constant CALLER_NOT_POOL_CONFIGURATOR = \"10\"; // 'The caller of the function is not the pool configurator'\n    string public constant CALLER_NOT_ATOKEN = \"11\"; // 'The caller of the function is not an AToken'\n    string public constant INVALID_ADDRESSES_PROVIDER = \"12\"; // 'The address of the pool addresses provider is invalid'\n    string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = \"13\"; // 'Invalid return value of the flashloan executor function'\n    string public constant RESERVE_ALREADY_ADDED = \"14\"; // 'Reserve has already been added to reserve list'\n    string public constant NO_MORE_RESERVES_ALLOWED = \"15\"; // 'Maximum amount of reserves in the pool reached'\n    string public constant EMODE_CATEGORY_RESERVED = \"16\"; // 'Zero eMode category is reserved for volatile heterogeneous assets'\n    string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = \"17\"; // 'Invalid eMode category assignment to asset'\n    string public constant RESERVE_LIQUIDITY_NOT_ZERO = \"18\"; // 'The liquidity of the reserve needs to be 0'\n    string public constant FLASHLOAN_PREMIUM_INVALID = \"19\"; // 'Invalid flashloan premium'\n    string public constant INVALID_RESERVE_PARAMS = \"20\"; // 'Invalid risk parameters for the reserve'\n    string public constant INVALID_EMODE_CATEGORY_PARAMS = \"21\"; // 'Invalid risk parameters for the eMode category'\n    string public constant BRIDGE_PROTOCOL_FEE_INVALID = \"22\"; // 'Invalid bridge protocol fee'\n    string public constant CALLER_MUST_BE_POOL = \"23\"; // 'The caller of this function must be a pool'\n    string public constant INVALID_MINT_AMOUNT = \"24\"; // 'Invalid amount to mint'\n    string public constant INVALID_BURN_AMOUNT = \"25\"; // 'Invalid amount to burn'\n    string public constant INVALID_AMOUNT = \"26\"; // 'Amount must be greater than 0'\n    string public constant RESERVE_INACTIVE = \"27\"; // 'Action requires an active reserve'\n    string public constant RESERVE_FROZEN = \"28\"; // 'Action cannot be performed because the reserve is frozen'\n    string public constant RESERVE_PAUSED = \"29\"; // 'Action cannot be performed because the reserve is paused'\n    string public constant BORROWING_NOT_ENABLED = \"30\"; // 'Borrowing is not enabled'\n    string public constant STABLE_BORROWING_NOT_ENABLED = \"31\"; // 'Stable borrowing is not enabled'\n    string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = \"32\"; // 'User cannot withdraw more than the available balance'\n    string public constant INVALID_INTEREST_RATE_MODE_SELECTED = \"33\"; // 'Invalid interest rate mode selected'\n    string public constant COLLATERAL_BALANCE_IS_ZERO = \"34\"; // 'The collateral balance is 0'\n    string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = \"35\"; // 'Health factor is lesser than the liquidation threshold'\n    string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = \"36\"; // 'There is not enough collateral to cover a new borrow'\n    string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = \"37\"; // 'Collateral is (mostly) the same currency that is being borrowed'\n    string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = \"38\"; // 'The requested amount is greater than the max loan size in stable rate mode'\n    string public constant NO_DEBT_OF_SELECTED_TYPE = \"39\"; // 'For repayment of a specific type of debt, the user needs to have debt that type'\n    string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \"40\"; // 'To repay on behalf of a user an explicit amount to repay is needed'\n    string public constant NO_OUTSTANDING_STABLE_DEBT = \"41\"; // 'User does not have outstanding stable rate debt on this reserve'\n    string public constant NO_OUTSTANDING_VARIABLE_DEBT = \"42\"; // 'User does not have outstanding variable rate debt on this reserve'\n    string public constant UNDERLYING_BALANCE_ZERO = \"43\"; // 'The underlying balance needs to be greater than 0'\n    string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \"44\"; // 'Interest rate rebalance conditions were not met'\n    string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \"45\"; // 'Health factor is not below the threshold'\n    string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = \"46\"; // 'The collateral chosen cannot be liquidated'\n    string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \"47\"; // 'User did not borrow the specified currency'\n    string public constant INCONSISTENT_FLASHLOAN_PARAMS = \"49\"; // 'Inconsistent flashloan parameters'\n    string public constant BORROW_CAP_EXCEEDED = \"50\"; // 'Borrow cap is exceeded'\n    string public constant SUPPLY_CAP_EXCEEDED = \"51\"; // 'Supply cap is exceeded'\n    string public constant UNBACKED_MINT_CAP_EXCEEDED = \"52\"; // 'Unbacked mint cap is exceeded'\n    string public constant DEBT_CEILING_EXCEEDED = \"53\"; // 'Debt ceiling is exceeded'\n    string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = \"54\"; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'\n    string public constant STABLE_DEBT_NOT_ZERO = \"55\"; // 'Stable debt supply is not zero'\n    string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = \"56\"; // 'Variable debt supply is not zero'\n    string public constant LTV_VALIDATION_FAILED = \"57\"; // 'Ltv validation failed'\n    string public constant INCONSISTENT_EMODE_CATEGORY = \"58\"; // 'Inconsistent eMode category'\n    string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = \"59\"; // 'Price oracle sentinel validation failed'\n    string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = \"60\"; // 'Asset is not borrowable in isolation mode'\n    string public constant RESERVE_ALREADY_INITIALIZED = \"61\"; // 'Reserve has already been initialized'\n    string public constant USER_IN_ISOLATION_MODE_OR_LTV_ZERO = \"62\"; // 'User is in isolation mode or ltv is zero'\n    string public constant INVALID_LTV = \"63\"; // 'Invalid ltv parameter for the reserve'\n    string public constant INVALID_LIQ_THRESHOLD = \"64\"; // 'Invalid liquidity threshold parameter for the reserve'\n    string public constant INVALID_LIQ_BONUS = \"65\"; // 'Invalid liquidity bonus parameter for the reserve'\n    string public constant INVALID_DECIMALS = \"66\"; // 'Invalid decimals parameter of the underlying asset of the reserve'\n    string public constant INVALID_RESERVE_FACTOR = \"67\"; // 'Invalid reserve factor parameter for the reserve'\n    string public constant INVALID_BORROW_CAP = \"68\"; // 'Invalid borrow cap for the reserve'\n    string public constant INVALID_SUPPLY_CAP = \"69\"; // 'Invalid supply cap for the reserve'\n    string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = \"70\"; // 'Invalid liquidation protocol fee for the reserve'\n    string public constant INVALID_EMODE_CATEGORY = \"71\"; // 'Invalid eMode category for the reserve'\n    string public constant INVALID_UNBACKED_MINT_CAP = \"72\"; // 'Invalid unbacked mint cap for the reserve'\n    string public constant INVALID_DEBT_CEILING = \"73\"; // 'Invalid debt ceiling for the reserve\n    string public constant INVALID_RESERVE_INDEX = \"74\"; // 'Invalid reserve index'\n    string public constant ACL_ADMIN_CANNOT_BE_ZERO = \"75\"; // 'ACL admin cannot be set to the zero address'\n    string public constant INCONSISTENT_PARAMS_LENGTH = \"76\"; // 'Array parameters that should be equal length are not'\n    string public constant ZERO_ADDRESS_NOT_VALID = \"77\"; // 'Zero address not valid'\n    string public constant INVALID_EXPIRATION = \"78\"; // 'Invalid expiration'\n    string public constant INVALID_SIGNATURE = \"79\"; // 'Invalid signature'\n    string public constant OPERATION_NOT_SUPPORTED = \"80\"; // 'Operation not supported'\n    string public constant DEBT_CEILING_NOT_ZERO = \"81\"; // 'Debt ceiling is not zero'\n    string public constant ASSET_NOT_LISTED = \"82\"; // 'Asset is not listed'\n    string public constant INVALID_OPTIMAL_USAGE_RATIO = \"83\"; // 'Invalid optimal usage ratio'\n    string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = \"84\"; // 'Invalid optimal stable to total debt ratio'\n    string public constant UNDERLYING_CANNOT_BE_RESCUED = \"85\"; // 'The underlying asset cannot be rescued'\n    string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = \"86\"; // 'Reserve has already been added to reserve list'\n    string public constant POOL_ADDRESSES_DO_NOT_MATCH = \"87\"; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'\n    string public constant STABLE_BORROWING_ENABLED = \"88\"; // 'Stable borrowing is enabled'\n    string public constant SILOED_BORROWING_VIOLATION = \"89\"; // 'User is trying to borrow multiple assets including a siloed one'\n    string public constant RESERVE_DEBT_NOT_ZERO = \"90\"; // the total debt of the reserve needs to be 0\n    string public constant FLASHLOAN_DISABLED = \"91\"; // FlashLoaning for this asset is disabled\n}\n"
    },
    "contracts/external/aave-v3/IAToken.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title IAToken\n * @author Aave\n * @notice Defines the basic interface for an AToken.\n */\ninterface IAToken is IERC20 {\n    /**\n     * @notice Returns the address of the underlying asset of this aToken (E.g. WETH for aWETH)\n     * @return The address of the underlying asset\n     */\n    function UNDERLYING_ASSET_ADDRESS() external view returns (address);\n}\n"
    },
    "contracts/external/aave-v3/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\nimport {DataTypes} from \"./DataTypes.sol\";\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n */\ninterface IPool {\n    /**\n     * @dev Emitted on mintUnbacked()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the supply\n     * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n     * @param amount The amount of supplied assets\n     * @param referralCode The referral code used\n     */\n    event MintUnbacked(\n        address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on backUnbacked()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param backer The address paying for the backing\n     * @param amount The amount added as backing\n     * @param fee The amount paid in fees\n     */\n    event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n    /**\n     * @dev Emitted on supply()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the supply\n     * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n     * @param amount The amount supplied\n     * @param referralCode The referral code used\n     */\n    event Supply(\n        address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlying asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to The address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     */\n    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n     * @param referralCode The referral code used\n     */\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 borrowRate,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the funds\n     * @param amount The amount repaid\n     * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n     */\n    event Repay(\n        address indexed reserve, address indexed user, address indexed repayer, uint256 amount, bool useATokens\n    );\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n     */\n    event SwapBorrowRateMode(\n        address indexed reserve, address indexed user, DataTypes.InterestRateMode interestRateMode\n    );\n\n    /**\n     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n     * @param asset The address of the underlying asset of the reserve\n     * @param totalDebt The total isolation mode debt for the reserve\n     */\n    event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n    /**\n     * @dev Emitted when the user selects a certain asset category for eMode\n     * @param user The address of the user\n     * @param categoryId The category id\n     */\n    event UserEModeSet(address indexed user, uint8 categoryId);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     */\n    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     */\n    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     */\n    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     */\n    event FlashLoan(\n        address indexed target,\n        address initiator,\n        address indexed asset,\n        uint256 amount,\n        DataTypes.InterestRateMode interestRateMode,\n        uint256 premium,\n        uint16 indexed referralCode\n    );\n\n    /**\n     * @dev Emitted when a borrower is liquidated.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     */\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated.\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The next liquidity rate\n     * @param stableBorrowRate The next stable borrow rate\n     * @param variableBorrowRate The next variable borrow rate\n     * @param liquidityIndex The next liquidity index\n     * @param variableBorrowIndex The next variable borrow index\n     */\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n     * @param reserve The address of the reserve\n     * @param amountMinted The amount minted to the treasury\n     */\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n    /**\n     * @notice Mints an `amount` of aTokens to the `onBehalfOf`\n     * @param asset The address of the underlying asset to mint\n     * @param amount The amount to mint\n     * @param onBehalfOf The address that will receive the aTokens\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function mintUnbacked(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n    /**\n     * @notice Back the current unbacked underlying with `amount` and pay `fee`.\n     * @param asset The address of the underlying asset to back\n     * @param amount The amount to back\n     * @param fee The amount paid in fees\n     * @return The backed amount\n     */\n    function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n    /**\n     * @notice Supply with transfer approval of asset to be supplied done via permit function\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     */\n    function supplyWithPermit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external;\n\n    /**\n     * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to The address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     */\n    function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n    /**\n     * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     */\n    function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf)\n        external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     */\n    function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf)\n        external\n        returns (uint256);\n\n    /**\n     * @notice Repay with transfer approval of asset to be repaid done via permit function\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @param deadline The deadline timestamp that the permit is valid\n     * @param permitV The V parameter of ERC712 permit sig\n     * @param permitR The R parameter of ERC712 permit sig\n     * @param permitS The S parameter of ERC712 permit sig\n     * @return The final amount repaid\n     */\n    function repayWithPermit(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        address onBehalfOf,\n        uint256 deadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external returns (uint256);\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n     * equivalent debt tokens\n     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n     * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n     * balance is not enough to cover the whole debt\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @return The final amount repaid\n     */\n    function repayWithATokens(address asset, uint256 amount, uint256 interestRateMode) external returns (uint256);\n\n    /**\n     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n     * @param asset The address of the underlying asset borrowed\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n     */\n    function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n    /**\n     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n     *        much has been borrowed at a stable rate and suppliers are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     */\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n     * @param asset The address of the underlying asset supplied\n     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n     */\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n    /**\n     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     */\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n     * into consideration. For further details please visit https://docs.aave.com/developers/\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts of the assets being flash-borrowed\n     * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata interestRateModes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n     * into consideration. For further details please visit https://docs.aave.com/developers/\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n     * @param asset The address of the asset being flash-borrowed\n     * @param amount The amount of the asset being flash-borrowed\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function flashLoanSimple(\n        address receiverAddress,\n        address asset,\n        uint256 amount,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @notice Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n     * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n     * @return currentLiquidationThreshold The liquidation threshold of the user\n     * @return ltv The loan to value of The user\n     * @return healthFactor The current health factor of the user\n     */\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralBase,\n            uint256 totalDebtBase,\n            uint256 availableBorrowsBase,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    /**\n     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n     * interest rate strategy\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n     * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\n     */\n    function initReserve(\n        address asset,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    /**\n     * @notice Drop a reserve\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     */\n    function dropReserve(address asset) external;\n\n    /**\n     * @notice Updates the address of the interest rate strategy contract\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param rateStrategyAddress The address of the interest rate strategy contract\n     */\n    function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) external;\n\n    /**\n     * @notice Sets the configuration bitmap of the reserve as a whole\n     * @dev Only callable by the PoolConfigurator contract\n     * @param asset The address of the underlying asset of the reserve\n     * @param configuration The new configuration bitmap\n     */\n    function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration) external;\n\n    /**\n     * @notice Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     */\n    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @notice Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     */\n    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @notice Returns the normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the normalized variable debt per unit of asset\n     * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a\n     * \"dynamic\" variable index based on time, current stored index and virtual rate at the current\n     * moment (approx. a borrower would get if opening a position). This means that is always used in\n     * combination with variable debt supply/balances.\n     * If using this function externally, consider that is possible to have an increasing normalized\n     * variable debt that is not equivalent to how the variable debt index would be updated in storage\n     * (e.g. only updates with non-zero variable debt supply)\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n    /**\n     * @notice Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state and configuration data of the reserve\n     */\n    function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n    /**\n     * @notice Validates and finalizes an aToken transfer\n     * @dev Only callable by the overlying aToken of the `asset`\n     * @param asset The address of the underlying asset of the aToken\n     * @param from The user from which the aTokens are transferred\n     * @param to The user receiving the aTokens\n     * @param amount The amount being transferred/withdrawn\n     * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n     * @param balanceToBefore The aToken balance of the `to` user before the transfer\n     */\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromBefore,\n        uint256 balanceToBefore\n    ) external;\n\n    /**\n     * @notice Returns the list of the underlying assets of all the initialized reserves\n     * @dev It does not include dropped reserves\n     * @return The addresses of the underlying assets of the initialized reserves\n     */\n    function getReservesList() external view returns (address[] memory);\n\n    /**\n     * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\n     * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\n     * @return The address of the reserve associated with id\n     */\n    function getReserveAddressById(uint16 id) external view returns (address);\n\n    /**\n     * @notice Returns the PoolAddressesProvider connected to this contract\n     * @return The address of the PoolAddressesProvider\n     */\n    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n    /**\n     * @notice Updates the protocol fee on the bridging\n     * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n     */\n    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n    /**\n     * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n     * - A part is sent to aToken holders as extra, one time accumulated interest\n     * - A part is collected by the protocol treasury\n     * @dev The total premium is calculated on the total borrowed amount\n     * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n     * @dev Only callable by the PoolConfigurator contract\n     * @param flashLoanPremiumTotal The total premium, expressed in bps\n     * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n     */\n    function updateFlashloanPremiums(uint128 flashLoanPremiumTotal, uint128 flashLoanPremiumToProtocol) external;\n\n    /**\n     * @notice Configures a new category for the eMode.\n     * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n     * The category 0 is reserved as it's the default for volatile assets\n     * @param id The id of the category\n     * @param config The configuration of the category\n     */\n    function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n    /**\n     * @notice Returns the data of an eMode category\n     * @param id The id of the category\n     * @return The configuration data of the category\n     */\n    function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n    /**\n     * @notice Allows a user to use the protocol in eMode\n     * @param categoryId The id of the category\n     */\n    function setUserEMode(uint8 categoryId) external;\n\n    /**\n     * @notice Returns the eMode the user is using\n     * @param user The address of the user\n     * @return The eMode id\n     */\n    function getUserEMode(address user) external view returns (uint256);\n\n    /**\n     * @notice Resets the isolation mode total debt of the given asset to zero\n     * @dev It requires the given asset has zero debt ceiling\n     * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n     */\n    function resetIsolationModeTotalDebt(address asset) external;\n\n    /**\n     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n     * @return The percentage of available liquidity to borrow, expressed in bps\n     */\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n    /**\n     * @notice Returns the total fee on flash loans\n     * @return The total fee on flashloans\n     */\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n    /**\n     * @notice Returns the part of the bridge fees sent to protocol\n     * @return The bridge fee sent to the protocol treasury\n     */\n    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n    /**\n     * @notice Returns the part of the flashloan fees sent to protocol\n     * @return The flashloan fee sent to the protocol treasury\n     */\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n    /**\n     * @notice Returns the maximum number of reserves supported to be listed in this Pool\n     * @return The maximum number of reserves supported\n     */\n    function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n    /**\n     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n     * @param assets The list of reserves for which the minting needs to be executed\n     */\n    function mintToTreasury(address[] calldata assets) external;\n\n    /**\n     * @notice Rescue and transfer tokens locked in this contract\n     * @param token The address of the token\n     * @param to The address of the recipient\n     * @param amount The amount of token to transfer\n     */\n    function rescueTokens(address token, address to, uint256 amount) external;\n\n    /**\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n     * @dev Deprecated: Use the `supply` function instead\n     * @param asset The address of the underlying asset to supply\n     * @param amount The amount to be supplied\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     */\n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n}\n"
    },
    "contracts/external/aave-v3/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n */\ninterface IPoolAddressesProvider {\n    /**\n     * @dev Emitted when the market identifier is updated.\n     * @param oldMarketId The old id of the market\n     * @param newMarketId The new id of the market\n     */\n    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n    /**\n     * @dev Emitted when the pool is updated.\n     * @param oldAddress The old address of the Pool\n     * @param newAddress The new address of the Pool\n     */\n    event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the pool configurator is updated.\n     * @param oldAddress The old address of the PoolConfigurator\n     * @param newAddress The new address of the PoolConfigurator\n     */\n    event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the price oracle is updated.\n     * @param oldAddress The old address of the PriceOracle\n     * @param newAddress The new address of the PriceOracle\n     */\n    event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the ACL manager is updated.\n     * @param oldAddress The old address of the ACLManager\n     * @param newAddress The new address of the ACLManager\n     */\n    event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the ACL admin is updated.\n     * @param oldAddress The old address of the ACLAdmin\n     * @param newAddress The new address of the ACLAdmin\n     */\n    event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the price oracle sentinel is updated.\n     * @param oldAddress The old address of the PriceOracleSentinel\n     * @param newAddress The new address of the PriceOracleSentinel\n     */\n    event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the pool data provider is updated.\n     * @param oldAddress The old address of the PoolDataProvider\n     * @param newAddress The new address of the PoolDataProvider\n     */\n    event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when a new proxy is created.\n     * @param id The identifier of the proxy\n     * @param proxyAddress The address of the created proxy contract\n     * @param implementationAddress The address of the implementation contract\n     */\n    event ProxyCreated(bytes32 indexed id, address indexed proxyAddress, address indexed implementationAddress);\n\n    /**\n     * @dev Emitted when a new non-proxied contract address is registered.\n     * @param id The identifier of the contract\n     * @param oldAddress The address of the old contract\n     * @param newAddress The address of the new contract\n     */\n    event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n    /**\n     * @dev Emitted when the implementation of the proxy registered with id is updated\n     * @param id The identifier of the contract\n     * @param proxyAddress The address of the proxy contract\n     * @param oldImplementationAddress The address of the old implementation contract\n     * @param newImplementationAddress The address of the new implementation contract\n     */\n    event AddressSetAsProxy(\n        bytes32 indexed id,\n        address indexed proxyAddress,\n        address oldImplementationAddress,\n        address indexed newImplementationAddress\n    );\n\n    /**\n     * @notice Returns the id of the Aave market to which this contract points to.\n     * @return The market id\n     */\n    function getMarketId() external view returns (string memory);\n\n    /**\n     * @notice Associates an id with a specific PoolAddressesProvider.\n     * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n     * identify and validate multiple Aave markets.\n     * @param newMarketId The market id\n     */\n    function setMarketId(string calldata newMarketId) external;\n\n    /**\n     * @notice Returns an address by its identifier.\n     * @dev The returned address might be an EOA or a contract, potentially proxied\n     * @dev It returns ZERO if there is no registered address with the given id\n     * @param id The id\n     * @return The address of the registered for the specified id\n     */\n    function getAddress(bytes32 id) external view returns (address);\n\n    /**\n     * @notice General function to update the implementation of a proxy registered with\n     * certain `id`. If there is no proxy registered, it will instantiate one and\n     * set as implementation the `newImplementationAddress`.\n     * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n     * setter function, in order to avoid unexpected consequences\n     * @param id The id\n     * @param newImplementationAddress The address of the new implementation\n     */\n    function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n    /**\n     * @notice Sets an address for an id replacing the address saved in the addresses map.\n     * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n     * @param id The id\n     * @param newAddress The address to set\n     */\n    function setAddress(bytes32 id, address newAddress) external;\n\n    /**\n     * @notice Returns the address of the Pool proxy.\n     * @return The Pool proxy address\n     */\n    function getPool() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the Pool, or creates a proxy\n     * setting the new `pool` implementation when the function is called for the first time.\n     * @param newPoolImpl The new Pool implementation\n     */\n    function setPoolImpl(address newPoolImpl) external;\n\n    /**\n     * @notice Returns the address of the PoolConfigurator proxy.\n     * @return The PoolConfigurator proxy address\n     */\n    function getPoolConfigurator() external view returns (address);\n\n    /**\n     * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n     * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n     * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n     */\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n    /**\n     * @notice Returns the address of the price oracle.\n     * @return The address of the PriceOracle\n     */\n    function getPriceOracle() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle.\n     * @param newPriceOracle The address of the new PriceOracle\n     */\n    function setPriceOracle(address newPriceOracle) external;\n\n    /**\n     * @notice Returns the address of the ACL manager.\n     * @return The address of the ACLManager\n     */\n    function getACLManager() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL manager.\n     * @param newAclManager The address of the new ACLManager\n     */\n    function setACLManager(address newAclManager) external;\n\n    /**\n     * @notice Returns the address of the ACL admin.\n     * @return The address of the ACL admin\n     */\n    function getACLAdmin() external view returns (address);\n\n    /**\n     * @notice Updates the address of the ACL admin.\n     * @param newAclAdmin The address of the new ACL admin\n     */\n    function setACLAdmin(address newAclAdmin) external;\n\n    /**\n     * @notice Returns the address of the price oracle sentinel.\n     * @return The address of the PriceOracleSentinel\n     */\n    function getPriceOracleSentinel() external view returns (address);\n\n    /**\n     * @notice Updates the address of the price oracle sentinel.\n     * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n     */\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n    /**\n     * @notice Returns the address of the data provider.\n     * @return The address of the DataProvider\n     */\n    function getPoolDataProvider() external view returns (address);\n\n    /**\n     * @notice Updates the address of the data provider.\n     * @param newDataProvider The address of the new DataProvider\n     */\n    function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "contracts/external/aave-v3/ReserveConfiguration.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {Errors} from \"./Errors.sol\";\nimport {DataTypes} from \"./DataTypes.sol\";\n\n/**\n * @title ReserveConfiguration library\n * @author Aave\n * @notice Implements the bitmap logic to handle the reserve configuration\n */\nlibrary ReserveConfiguration {\n    uint256 internal constant LTV_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore\n    uint256 internal constant LIQUIDATION_THRESHOLD_MASK =\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore\n    uint256 internal constant LIQUIDATION_BONUS_MASK =\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore\n    uint256 internal constant DECIMALS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant STABLE_BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant PAUSED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant SILOED_BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant FLASHLOAN_ENABLED_MASK =\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant BORROW_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant SUPPLY_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =\n        0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant EMODE_CATEGORY_MASK = 0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant UNBACKED_MINT_CAP_MASK =\n        0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n    uint256 internal constant DEBT_CEILING_MASK = 0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n\n    /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed\n    uint256 internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;\n    uint256 internal constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;\n    uint256 internal constant RESERVE_DECIMALS_START_BIT_POSITION = 48;\n    uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;\n    uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;\n    uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;\n    uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;\n    uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;\n    uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;\n    uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;\n    uint256 internal constant FLASHLOAN_ENABLED_START_BIT_POSITION = 63;\n    uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;\n    uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;\n    uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;\n    uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;\n    uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;\n    uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;\n    uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;\n\n    uint256 internal constant MAX_VALID_LTV = 65535;\n    uint256 internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;\n    uint256 internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;\n    uint256 internal constant MAX_VALID_DECIMALS = 255;\n    uint256 internal constant MAX_VALID_RESERVE_FACTOR = 65535;\n    uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;\n    uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;\n    uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;\n    uint256 internal constant MAX_VALID_EMODE_CATEGORY = 255;\n    uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;\n    uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;\n\n    uint256 public constant DEBT_CEILING_DECIMALS = 2;\n    uint16 public constant MAX_RESERVES_COUNT = 128;\n\n    /**\n     * @notice Sets the Loan to Value of the reserve\n     * @param self The reserve configuration\n     * @param ltv The new ltv\n     */\n    function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {\n        require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);\n\n        self.data = (self.data & LTV_MASK) | ltv;\n    }\n\n    /**\n     * @notice Gets the Loan to Value of the reserve\n     * @param self The reserve configuration\n     * @return The loan to value\n     */\n    function getLtv(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return self.data & ~LTV_MASK;\n    }\n\n    /**\n     * @notice Sets the liquidation threshold of the reserve\n     * @param self The reserve configuration\n     * @param threshold The new liquidation threshold\n     */\n    function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold) internal pure {\n        require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.INVALID_LIQ_THRESHOLD);\n\n        self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the liquidation threshold of the reserve\n     * @param self The reserve configuration\n     * @return The liquidation threshold\n     */\n    function getLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the liquidation bonus of the reserve\n     * @param self The reserve configuration\n     * @param bonus The new liquidation bonus\n     */\n    function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus) internal pure {\n        require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);\n\n        self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the liquidation bonus of the reserve\n     * @param self The reserve configuration\n     * @return The liquidation bonus\n     */\n    function getLiquidationBonus(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the decimals of the underlying asset of the reserve\n     * @param self The reserve configuration\n     * @param decimals The decimals\n     */\n    function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals) internal pure {\n        require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);\n\n        self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the decimals of the underlying asset of the reserve\n     * @param self The reserve configuration\n     * @return The decimals of the asset\n     */\n    function getDecimals(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the active state of the reserve\n     * @param self The reserve configuration\n     * @param active The active state\n     */\n    function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {\n        self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the active state of the reserve\n     * @param self The reserve configuration\n     * @return The active state\n     */\n    function getActive(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~ACTIVE_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the frozen state of the reserve\n     * @param self The reserve configuration\n     * @param frozen The frozen state\n     */\n    function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {\n        self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the frozen state of the reserve\n     * @param self The reserve configuration\n     * @return The frozen state\n     */\n    function getFrozen(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~FROZEN_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the paused state of the reserve\n     * @param self The reserve configuration\n     * @param paused The paused state\n     */\n    function setPaused(DataTypes.ReserveConfigurationMap memory self, bool paused) internal pure {\n        self.data = (self.data & PAUSED_MASK) | (uint256(paused ? 1 : 0) << IS_PAUSED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the paused state of the reserve\n     * @param self The reserve configuration\n     * @return The paused state\n     */\n    function getPaused(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~PAUSED_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the borrowable in isolation flag for the reserve.\n     * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed\n     * amount will be accumulated in the isolated collateral's total debt exposure.\n     * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n     * consistency in the debt ceiling calculations.\n     * @param self The reserve configuration\n     * @param borrowable True if the asset is borrowable\n     */\n    function setBorrowableInIsolation(DataTypes.ReserveConfigurationMap memory self, bool borrowable) internal pure {\n        self.data = (self.data & BORROWABLE_IN_ISOLATION_MASK)\n            | (uint256(borrowable ? 1 : 0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the borrowable in isolation flag for the reserve.\n     * @dev If the returned flag is true, the asset is borrowable against isolated collateral. Assets borrowed with\n     * isolated collateral is accounted for in the isolated collateral's total debt exposure.\n     * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep\n     * consistency in the debt ceiling calculations.\n     * @param self The reserve configuration\n     * @return The borrowable in isolation flag\n     */\n    function getBorrowableInIsolation(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the siloed borrowing flag for the reserve.\n     * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n     * @param self The reserve configuration\n     * @param siloed True if the asset is siloed\n     */\n    function setSiloedBorrowing(DataTypes.ReserveConfigurationMap memory self, bool siloed) internal pure {\n        self.data =\n            (self.data & SILOED_BORROWING_MASK) | (uint256(siloed ? 1 : 0) << SILOED_BORROWING_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the siloed borrowing flag for the reserve.\n     * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.\n     * @param self The reserve configuration\n     * @return The siloed borrowing flag\n     */\n    function getSiloedBorrowing(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~SILOED_BORROWING_MASK) != 0;\n    }\n\n    /**\n     * @notice Enables or disables borrowing on the reserve\n     * @param self The reserve configuration\n     * @param enabled True if the borrowing needs to be enabled, false otherwise\n     */\n    function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\n        self.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the borrowing state of the reserve\n     * @param self The reserve configuration\n     * @return The borrowing state\n     */\n    function getBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~BORROWING_MASK) != 0;\n    }\n\n    /**\n     * @notice Enables or disables stable rate borrowing on the reserve\n     * @param self The reserve configuration\n     * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise\n     */\n    function setStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {\n        self.data = (self.data & STABLE_BORROWING_MASK)\n            | (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the stable rate borrowing state of the reserve\n     * @param self The reserve configuration\n     * @return The stable rate borrowing state\n     */\n    function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (bool)\n    {\n        return (self.data & ~STABLE_BORROWING_MASK) != 0;\n    }\n\n    /**\n     * @notice Sets the reserve factor of the reserve\n     * @param self The reserve configuration\n     * @param reserveFactor The reserve factor\n     */\n    function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor) internal pure {\n        require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.INVALID_RESERVE_FACTOR);\n\n        self.data = (self.data & RESERVE_FACTOR_MASK) | (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the reserve factor of the reserve\n     * @param self The reserve configuration\n     * @return The reserve factor\n     */\n    function getReserveFactor(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the borrow cap of the reserve\n     * @param self The reserve configuration\n     * @param borrowCap The borrow cap\n     */\n    function setBorrowCap(DataTypes.ReserveConfigurationMap memory self, uint256 borrowCap) internal pure {\n        require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);\n\n        self.data = (self.data & BORROW_CAP_MASK) | (borrowCap << BORROW_CAP_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the borrow cap of the reserve\n     * @param self The reserve configuration\n     * @return The borrow cap\n     */\n    function getBorrowCap(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the supply cap of the reserve\n     * @param self The reserve configuration\n     * @param supplyCap The supply cap\n     */\n    function setSupplyCap(DataTypes.ReserveConfigurationMap memory self, uint256 supplyCap) internal pure {\n        require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);\n\n        self.data = (self.data & SUPPLY_CAP_MASK) | (supplyCap << SUPPLY_CAP_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the supply cap of the reserve\n     * @param self The reserve configuration\n     * @return The supply cap\n     */\n    function getSupplyCap(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the debt ceiling in isolation mode for the asset\n     * @param self The reserve configuration\n     * @param ceiling The maximum debt ceiling for the asset\n     */\n    function setDebtCeiling(DataTypes.ReserveConfigurationMap memory self, uint256 ceiling) internal pure {\n        require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);\n\n        self.data = (self.data & DEBT_CEILING_MASK) | (ceiling << DEBT_CEILING_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the debt ceiling for the asset if the asset is in isolation mode\n     * @param self The reserve configuration\n     * @return The debt ceiling (0 = isolation mode disabled)\n     */\n    function getDebtCeiling(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the liquidation protocol fee of the reserve\n     * @param self The reserve configuration\n     * @param liquidationProtocolFee The liquidation protocol fee\n     */\n    function setLiquidationProtocolFee(DataTypes.ReserveConfigurationMap memory self, uint256 liquidationProtocolFee)\n        internal\n        pure\n    {\n        require(liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE, Errors.INVALID_LIQUIDATION_PROTOCOL_FEE);\n\n        self.data = (self.data & LIQUIDATION_PROTOCOL_FEE_MASK)\n            | (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION);\n    }\n\n    /**\n     * @dev Gets the liquidation protocol fee\n     * @param self The reserve configuration\n     * @return The liquidation protocol fee\n     */\n    function getLiquidationProtocolFee(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~LIQUIDATION_PROTOCOL_FEE_MASK) >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the unbacked mint cap of the reserve\n     * @param self The reserve configuration\n     * @param unbackedMintCap The unbacked mint cap\n     */\n    function setUnbackedMintCap(DataTypes.ReserveConfigurationMap memory self, uint256 unbackedMintCap) internal pure {\n        require(unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP, Errors.INVALID_UNBACKED_MINT_CAP);\n\n        self.data = (self.data & UNBACKED_MINT_CAP_MASK) | (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION);\n    }\n\n    /**\n     * @dev Gets the unbacked mint cap of the reserve\n     * @param self The reserve configuration\n     * @return The unbacked mint cap\n     */\n    function getUnbackedMintCap(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the eMode asset category\n     * @param self The reserve configuration\n     * @param category The asset category when the user selects the eMode\n     */\n    function setEModeCategory(DataTypes.ReserveConfigurationMap memory self, uint256 category) internal pure {\n        require(category <= MAX_VALID_EMODE_CATEGORY, Errors.INVALID_EMODE_CATEGORY);\n\n        self.data = (self.data & EMODE_CATEGORY_MASK) | (category << EMODE_CATEGORY_START_BIT_POSITION);\n    }\n\n    /**\n     * @dev Gets the eMode asset category\n     * @param self The reserve configuration\n     * @return The eMode category for the asset\n     */\n    function getEModeCategory(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {\n        return (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;\n    }\n\n    /**\n     * @notice Sets the flashloanable flag for the reserve\n     * @param self The reserve configuration\n     * @param flashLoanEnabled True if the asset is flashloanable, false otherwise\n     */\n    function setFlashLoanEnabled(DataTypes.ReserveConfigurationMap memory self, bool flashLoanEnabled) internal pure {\n        self.data = (self.data & FLASHLOAN_ENABLED_MASK)\n            | (uint256(flashLoanEnabled ? 1 : 0) << FLASHLOAN_ENABLED_START_BIT_POSITION);\n    }\n\n    /**\n     * @notice Gets the flashloanable flag for the reserve\n     * @param self The reserve configuration\n     * @return The flashloanable flag\n     */\n    function getFlashLoanEnabled(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {\n        return (self.data & ~FLASHLOAN_ENABLED_MASK) != 0;\n    }\n\n    /**\n     * @notice Gets the configuration flags of the reserve\n     * @param self The reserve configuration\n     * @return The state flag representing active\n     * @return The state flag representing frozen\n     * @return The state flag representing borrowing enabled\n     * @return The state flag representing stableRateBorrowing enabled\n     * @return The state flag representing paused\n     */\n    function getFlags(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (bool, bool, bool, bool, bool)\n    {\n        uint256 dataLocal = self.data;\n\n        return (\n            (dataLocal & ~ACTIVE_MASK) != 0,\n            (dataLocal & ~FROZEN_MASK) != 0,\n            (dataLocal & ~BORROWING_MASK) != 0,\n            (dataLocal & ~STABLE_BORROWING_MASK) != 0,\n            (dataLocal & ~PAUSED_MASK) != 0\n        );\n    }\n\n    /**\n     * @notice Gets the configuration parameters of the reserve from storage\n     * @param self The reserve configuration\n     * @return The state param representing ltv\n     * @return The state param representing liquidation threshold\n     * @return The state param representing liquidation bonus\n     * @return The state param representing reserve decimals\n     * @return The state param representing reserve factor\n     * @return The state param representing eMode category\n     */\n    function getParams(DataTypes.ReserveConfigurationMap memory self)\n        internal\n        pure\n        returns (uint256, uint256, uint256, uint256, uint256, uint256)\n    {\n        uint256 dataLocal = self.data;\n\n        return (\n            dataLocal & ~LTV_MASK,\n            (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,\n            (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,\n            (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,\n            (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,\n            (dataLocal & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION\n        );\n    }\n\n    /**\n     * @notice Gets the caps parameters of the reserve from storage\n     * @param self The reserve configuration\n     * @return The state param representing borrow cap\n     * @return The state param representing supply cap.\n     */\n    function getCaps(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256, uint256) {\n        uint256 dataLocal = self.data;\n\n        return (\n            (dataLocal & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,\n            (dataLocal & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION\n        );\n    }\n}\n"
    },
    "contracts/external/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "contracts/external/clober/CloberMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ninterface CloberMarketFactory {\n    /**\n     * @notice Emitted when a new volatile market is created.\n     * @param market The address of the new market.\n     * @param orderToken The address of the new market's order token.\n     * @param quoteToken The address of the new market's quote token.\n     * @param baseToken The address of the new market's base token.\n     * @param quoteUnit The amount that one raw amount represents in quote tokens.\n     * @param nonce The nonce for this market.\n     * @param makerFee The maker fee.\n     * Paid to the maker when negative, paid by the maker when positive.\n     * Every 10000 represents a 1% fee on trade volume.\n     * @param takerFee The taker fee.\n     * Paid by the taker.\n     * Every 10000 represents a 1% fee on trade volume.\n     * @param a The scale factor of the price points.\n     * @param r The common ratio between price points.\n     */\n    event CreateVolatileMarket(\n        address indexed market,\n        address orderToken,\n        address quoteToken,\n        address baseToken,\n        uint256 quoteUnit,\n        uint256 nonce,\n        int24 makerFee,\n        uint24 takerFee,\n        uint128 a,\n        uint128 r\n    );\n\n    /**\n     * @notice Emitted when a new stable market is created.\n     * @param market The address of the new market.\n     * @param orderToken The address of the new market's order token.\n     * @param quoteToken The address of the new market's quote token.\n     * @param baseToken The address of the new market's base token.\n     * @param quoteUnit The amount that one raw amount represents in quote tokens.\n     * @param nonce The nonce for this market.\n     * @param makerFee The maker fee.\n     * Paid to the maker when negative, paid by the maker when positive.\n     * Every 10000 represents a 1% fee on trade volume.\n     * @param takerFee The taker fee.\n     * Paid by the taker.\n     * Every 10000 represents a 1% fee on trade volume.\n     * @param a The starting price point.\n     * @param d The common difference between price points.\n     */\n    event CreateStableMarket(\n        address indexed market,\n        address orderToken,\n        address quoteToken,\n        address baseToken,\n        uint256 quoteUnit,\n        uint256 nonce,\n        int24 makerFee,\n        uint24 takerFee,\n        uint128 a,\n        uint128 d\n    );\n\n    /**\n     * @notice Emitted when the address of the owner has changed.\n     * @param previousOwner The address of the previous owner.\n     * @param newOwner The address of the new owner.\n     */\n    event ChangeOwner(address previousOwner, address newOwner);\n\n    /**\n     * @notice Emitted when the DAO Treasury address has changed.\n     * @param previousTreasury The address of the previous DAO Treasury.\n     * @param newTreasury The address of the new DAO Treasury.\n     */\n    event ChangeDaoTreasury(address previousTreasury, address newTreasury);\n\n    /**\n     * @notice Emitted when the host address has changed.\n     * @param market The address of the market that had a change of hosts.\n     * @param previousHost The address of the previous host.\n     * @param newHost The address of a new host.\n     */\n    event ChangeHost(address indexed market, address previousHost, address newHost);\n\n    /**\n     * @notice Returns the address of the deployed GeometricPriceBook.\n     * @return The address of the GeometricPriceBook.\n     */\n    function deployedGeometricPriceBook(uint128 a, uint128 r) external view returns (address);\n\n    /**\n     * @notice Returns the address of the deployed GeometricPriceBook.\n     * @return The address of the GeometricPriceBook.\n     */\n    function deployedArithmeticPriceBook(uint128 a, uint128 d) external view returns (address);\n\n    /**\n     * @notice Returns the address of the MarketDeployer.\n     * @return The address of the MarketDeployer.\n     */\n    function marketDeployer() external view returns (address);\n\n    /**\n     * @notice Returns the address of the priceBookDeployer.\n     * @return The address of the priceBookDeployer.\n     */\n    function priceBookDeployer() external view returns (address);\n\n    /**\n     * @notice Returns the address of the orderTokenDeployer.\n     * @return The address of the orderTokenDeployer.\n     */\n    function orderTokenDeployer() external view returns (address);\n\n    /**\n     * @notice Returns the address of the OrderCanceler.\n     * @return The address of the OrderCanceler.\n     */\n    function canceler() external view returns (address);\n\n    /**\n     * @notice Returns whether the specified token address has been registered as a quote token.\n     * @param token The address of the token to check.\n     * @return bool Whether the token is registered as a quote token.\n     */\n    function registeredQuoteTokens(address token) external view returns (bool);\n\n    /**\n     * @notice Returns the address of the factory owner\n     * @return The address of the factory owner\n     */\n    function owner() external view returns (address);\n\n    /**\n     * @notice Returns the address of the factory owner candidate\n     * @return The address of the factory owner candidate\n     */\n    function futureOwner() external view returns (address);\n\n    /**\n     * @notice Returns the address of the DAO Treasury\n     * @return The address of the DAO Treasury\n     */\n    function daoTreasury() external view returns (address);\n\n    /**\n     * @notice Returns the current nonce\n     * @return The current nonce\n     */\n    function nonce() external view returns (uint256);\n\n    /**\n     * @notice Creates a new market with a VolatilePriceBook.\n     * @param host The address of the new market's host.\n     * @param quoteToken The address of the new market's quote token.\n     * @param baseToken The address of the new market's base token.\n     * @param quoteUnit The amount that one raw amount represents in quote tokens.\n     * @param makerFee The maker fee.\n     * Paid to the maker when negative, paid by the maker when positive.\n     * Every 10000 represents a 1% fee on trade volume.\n     * @param takerFee The taker fee.\n     * Paid by the taker.\n     * Every 10000 represents a 1% fee on trade volume.\n     * @param a The scale factor of the price points.\n     * @param r The common ratio between price points.\n     * @return The address of the created market.\n     */\n    function createVolatileMarket(\n        address host,\n        address quoteToken,\n        address baseToken,\n        uint96 quoteUnit,\n        int24 makerFee,\n        uint24 takerFee,\n        uint128 a,\n        uint128 r\n    ) external returns (address);\n\n    /**\n     * @notice Creates a new market with a StablePriceBook\n     * @param host The address of the new market's host\n     * @param quoteToken The address of the new market's quote token\n     * @param baseToken The address of the new market's base token\n     * @param quoteUnit The amount that one raw amount represents in quote tokens\n     * @param makerFee The maker fee.\n     * Paid to the maker when negative, paid by the maker when positive.\n     * Every 10000 represents a 1% fee on trade volume.\n     * @param takerFee The taker fee.\n     * Paid by the taker.\n     * Every 10000 represents a 1% fee on trade volume.\n     * @param a The starting price point.\n     * @param d The common difference between price points.\n     * @return The address of the created market.\n     */\n    function createStableMarket(\n        address host,\n        address quoteToken,\n        address baseToken,\n        uint96 quoteUnit,\n        int24 makerFee,\n        uint24 takerFee,\n        uint128 a,\n        uint128 d\n    ) external returns (address);\n\n    /**\n     * @notice Change the DAO Treasury address.\n     * @dev Only the factory owner can call this function.\n     * @param treasury The new address of the DAO Treasury.\n     */\n    function changeDaoTreasury(address treasury) external;\n\n    /**\n     * @notice Sets the new owner address for this contract.\n     * @dev Only the factory owner can call this function.\n     * @param newOwner The new owner address for this contract.\n     */\n    function prepareChangeOwner(address newOwner) external;\n\n    /**\n     * @notice Changes the owner of this contract to the address set by `prepareChangeOwner`.\n     * @dev Only the future owner can call this function.\n     */\n    function executeChangeOwner() external;\n\n    /**\n     * @notice Returns the host address of the given market.\n     * @param market The address of the target market.\n     * @return The host address of the market.\n     */\n    function getMarketHost(address market) external view returns (address);\n\n    /**\n     * @notice Prepares to set a new host address for the given market address.\n     * @dev Only the market host can call this function.\n     * @param market The market address for which the host will be changed.\n     * @param newHost The new host address for the given market.\n     */\n    function prepareHandOverHost(address market, address newHost) external;\n\n    /**\n     * @notice Changes the host address of the given market to the address set by `prepareHandOverHost`.\n     * @dev Only the future market host can call this function.\n     * @param market The market address for which the host will be changed.\n     */\n    function executeHandOverHost(address market) external;\n\n    enum MarketType {\n        NONE,\n        VOLATILE,\n        STABLE\n    }\n\n    /**\n     * @notice MarketInfo struct that contains information about a market.\n     * @param host The address of the market host.\n     * @param marketType The market type, either VOLATILE or STABLE.\n     * @param a The starting price point.\n     * @param factor The either the common ratio or common difference between price points.\n     * @param futureHost The address set by `prepareHandOverHost` to change the market host.\n     */\n    struct MarketInfo {\n        address host;\n        MarketType marketType;\n        uint128 a;\n        uint128 factor;\n        address futureHost;\n    }\n\n    /**\n     * @notice Returns key information about the market.\n     * @param market The address of the market.\n     * @return marketInfo The MarketInfo structure of the given market.\n     */\n    function getMarketInfo(address market) external view returns (MarketInfo memory marketInfo);\n\n    /**\n     * @notice Allows the specified token to be used as the quote token.\n     * @dev Only the factory owner can call this function.\n     * @param token The address of the token to register.\n     */\n    function registerQuoteToken(address token) external;\n\n    /**\n     * @notice Revokes the token's right to be used as a quote token.\n     * @dev Only the factory owner can call this function.\n     * @param token The address of the token to unregister.\n     */\n    function unregisterQuoteToken(address token) external;\n\n    /**\n     * @notice Returns the order token name.\n     * @param quoteToken The address of the market's quote token.\n     * @param baseToken The address of the market's base token.\n     * @param marketNonce The market nonce.\n     * @return The order token name.\n     */\n    function formatOrderTokenName(address quoteToken, address baseToken, uint256 marketNonce)\n        external\n        view\n        returns (string memory);\n\n    /**\n     * @notice Returns the order token symbol.\n     * @param quoteToken The address of a new market's quote token.\n     * @param baseToken The address of a new market's base token.\n     * @param marketNonce The market nonce.\n     * @return The order token symbol.\n     */\n    function formatOrderTokenSymbol(address quoteToken, address baseToken, uint256 marketNonce)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/external/clober/CloberMarketSwapCallbackReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ninterface CloberMarketSwapCallbackReceiver {\n    /**\n     * @notice Contracts placing orders on the OrderBook must implement this method.\n     * In this method, the contract has to send the required token, or the transaction will revert.\n     * If there is a claim bounty to be refunded, it will be transferred via msg.value.\n     * @param inputToken The address of the token the user has to send.\n     * @param outputToken The address of the token the user has received.\n     * @param inputAmount The amount of tokens the user has to send.\n     * @param outputAmount The amount of tokens the user has received.\n     * @param data The user's custom callback data.\n     */\n    function cloberMarketSwapCallback(\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes calldata data\n    ) external payable;\n}\n"
    },
    "contracts/external/clober/CloberOrderBook.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport \"./CloberOrderKey.sol\";\n\ninterface CloberOrderBook {\n    /**\n     * @notice Emitted when an order is created.\n     * @param sender The address who sent the tokens to make the order.\n     * @param user The address with the rights to claim the proceeds of the order.\n     * @param rawAmount The ordered raw amount.\n     * @param orderIndex The order index.\n     * @param priceIndex The price book index.\n     * @param options LSB: 0 - Ask, 1 - Bid.\n     */\n    event MakeOrder(\n        address indexed sender,\n        address indexed user,\n        uint64 rawAmount,\n        uint32 claimBounty,\n        uint256 orderIndex,\n        uint16 priceIndex,\n        uint8 options\n    );\n\n    /**\n     * @notice Emitted when an order takes from the order book.\n     * @param sender The address who sent the tokens to take the order.\n     * @param user The recipient address of the traded token.\n     * @param priceIndex The price book index.\n     * @param rawAmount The ordered raw amount.\n     * @param options MSB: 0 - Limit, 1 - Market / LSB: 0 - Ask, 1 - Bid.\n     */\n    event TakeOrder(address indexed sender, address indexed user, uint16 priceIndex, uint64 rawAmount, uint8 options);\n\n    /**\n     * @notice Emitted when an order is canceled.\n     * @param user The owner of the order.\n     * @param rawAmount The raw amount remaining that was canceled.\n     * @param orderIndex The order index.\n     * @param priceIndex The price book index.\n     * @param isBid The flag indicating whether it's a bid order or an ask order.\n     */\n    event CancelOrder(address indexed user, uint64 rawAmount, uint256 orderIndex, uint16 priceIndex, bool isBid);\n\n    /**\n     * @notice Emitted when the proceeds of an order is claimed.\n     * @param claimer The address that initiated the claim.\n     * @param user The owner of the order.\n     * @param rawAmount The ordered raw amount.\n     * @param bountyAmount The size of the claim bounty.\n     * @param orderIndex The order index.\n     * @param priceIndex The price book index.\n     * @param isBase The flag indicating whether the user receives the base token or the quote token.\n     */\n    event ClaimOrder(\n        address indexed claimer,\n        address indexed user,\n        uint64 rawAmount,\n        uint256 bountyAmount,\n        uint256 orderIndex,\n        uint16 priceIndex,\n        bool isBase\n    );\n\n    /**\n     * @notice Emitted when a flash-loan is taken.\n     * @param caller The caller address of the flash-loan.\n     * @param borrower The address of the flash loan token receiver.\n     * @param quoteAmount The amount of quote tokens the user has borrowed.\n     * @param baseAmount The amount of base tokens the user has borrowed.\n     * @param earnedQuote The amount of quote tokens the protocol earned in quote tokens.\n     * @param earnedBase The amount of base tokens the protocol earned in base tokens.\n     */\n    event Flash(\n        address indexed caller,\n        address indexed borrower,\n        uint256 quoteAmount,\n        uint256 baseAmount,\n        uint256 earnedQuote,\n        uint256 earnedBase\n    );\n\n    /**\n     * @notice A struct that represents an order.\n     * @param amount The raw amount not filled yet. In case of a stale order, the amount not claimed yet.\n     * @param claimBounty The bounty amount in gwei that can be collected by the party that fully claims the order.\n     * @param owner The address of the order owner.\n     */\n    struct Order {\n        uint64 amount;\n        uint32 claimBounty;\n        address owner;\n    }\n\n    /**\n     * @notice A struct that represents a block trade log.\n     * @param blockTime The timestamp of the block.\n     * @param askVolume The volume taken on the ask side.\n     * @param bidVolume The volume taken on the bid side.\n     * @param open The price book index on the open.\n     * @param high The highest price book index in the block.\n     * @param low The lowest price book index in the block.\n     * @param close The price book index on the close.\n     */\n    struct BlockTradeLog {\n        uint64 blockTime;\n        uint64 askVolume;\n        uint64 bidVolume;\n        uint16 open;\n        uint16 high;\n        uint16 low;\n        uint16 close;\n    }\n\n    /**\n     * @notice Take orders better or equal to the given priceIndex and make an order with the remaining tokens.\n     * @dev `msg.value` will be used as the claimBounty.\n     * @param user The taker/maker address.\n     * @param priceIndex The price book index.\n     * @param rawAmount The raw quote amount to trade, utilized by bids.\n     * @param baseAmount The base token amount to trade, utilized by asks.\n     * @param options LSB: 0 - Ask, 1 - Bid. Second bit: 1 - Post only.\n     * @param data Custom callback data\n     * @return The order index. If an order is not made `type(uint256).max` is returned instead.\n     */\n    function limitOrder(\n        address user,\n        uint16 priceIndex,\n        uint64 rawAmount,\n        uint256 baseAmount,\n        uint8 options,\n        bytes calldata data\n    ) external payable returns (uint256);\n\n    /**\n     * @notice Returns the expected input amount and output amount.\n     * @param limitPriceIndex The price index to take until.\n     * @param rawAmount The raw amount to trade.\n     * Bid & expendInput => Used as input amount.\n     * Bid & !expendInput => Not used.\n     * Ask & expendInput => Not used.\n     * Ask & !expendInput => Used as output amount.\n     * @param baseAmount The base token amount to trade.\n     * Bid & expendInput => Not used.\n     * Bid & !expendInput => Used as output amount.\n     * Ask & expendInput => Used as input amount.\n     * Ask & !expendInput => Not used.\n     * @param options LSB: 0 - Ask, 1 - Bid. Second bit: 1 - expend input.\n     */\n    function getExpectedAmount(uint16 limitPriceIndex, uint64 rawAmount, uint256 baseAmount, uint8 options)\n        external\n        view\n        returns (uint256, uint256);\n\n    /**\n     * @notice Take opens orders until certain conditions are met.\n     * @param user The taker address.\n     * @param limitPriceIndex The price index to take until.\n     * @param rawAmount The raw amount to trade.\n     * This value is used as the maximum input amount by bids and minimum output amount by asks.\n     * @param baseAmount The base token amount to trade.\n     * This value is used as the maximum input amount by asks and minimum output amount by bids.\n     * @param options LSB: 0 - Ask, 1 - Bid. Second bit: 1 - expend input.\n     * @param data Custom callback data.\n     */\n    function marketOrder(\n        address user,\n        uint16 limitPriceIndex,\n        uint64 rawAmount,\n        uint256 baseAmount,\n        uint8 options,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @notice Cancel orders.\n     * @dev The length of orderKeys must be controlled by the caller to avoid block gas limit exceeds.\n     * @param receiver The address to receive canceled tokens.\n     * @param orderKeys The order keys of the orders to cancel.\n     */\n    function cancel(address receiver, OrderKey[] calldata orderKeys) external;\n\n    /**\n     * @notice Claim the proceeds of orders.\n     * @dev The length of orderKeys must be controlled by the caller to avoid block gas limit exceeds.\n     * @param claimer The address to receive the claim bounties.\n     * @param orderKeys The order keys of the orders to claim.\n     */\n    function claim(address claimer, OrderKey[] calldata orderKeys) external;\n\n    /**\n     * @notice Get the claimable proceeds of an order.\n     * @param orderKey The order key of the order.\n     * @return claimableRawAmount The claimable raw amount.\n     * @return claimableAmount The claimable amount after fees.\n     * @return feeAmount The maker fee to be paid on claim.\n     * @return rebateAmount The rebate to be received on claim.\n     */\n    function getClaimable(OrderKey calldata orderKey)\n        external\n        view\n        returns (uint64 claimableRawAmount, uint256 claimableAmount, uint256 feeAmount, uint256 rebateAmount);\n\n    /**\n     * @notice Flash loan the tokens in the OrderBook.\n     * @param borrower The address to receive the loan.\n     * @param quoteAmount The quote token amount to borrow.\n     * @param baseAmount The base token amount to borrow.\n     * @param data The user's custom callback data.\n     */\n    function flash(address borrower, uint256 quoteAmount, uint256 baseAmount, bytes calldata data) external;\n\n    /**\n     * @notice Returns the quote unit amount.\n     * @return The amount that one raw amount represent in quote tokens.\n     */\n    function quoteUnit() external view returns (uint256);\n\n    /**\n     * @notice Returns the maker fee.\n     * Paid to the maker when negative, paid by the maker when positive.\n     * Every 10000 represents a 1% fee on trade volume.\n     * @return The maker fee. 100 = 1bp.\n     */\n    function makerFee() external view returns (int24);\n\n    /**\n     * @notice Returns the take fee\n     * Paid by the taker.\n     * Every 10000 represents a 1% fee on trade volume.\n     * @return The taker fee. 100 = 1bps.\n     */\n    function takerFee() external view returns (uint24);\n\n    /**\n     * @notice Returns the address of the order NFT contract.\n     * @return The address of the order NFT contract.\n     */\n    function orderToken() external view returns (address);\n\n    /**\n     * @notice Returns the address of the quote token.\n     * @return The address of the quote token.\n     */\n    function quoteToken() external view returns (address);\n\n    /**\n     * @notice Returns the address of the base token.\n     * @return The address of the base token.\n     */\n    function baseToken() external view returns (address);\n\n    /**\n     * @notice Returns the current total open amount at the given price.\n     * @param isBid The flag to choose which side to check the depth for.\n     * @param priceIndex The price book index.\n     * @return The total open amount.\n     */\n    function getDepth(bool isBid, uint16 priceIndex) external view returns (uint64);\n\n    /**\n     * @notice Returns the fee balance that has not been collected yet.\n     * @return quote The current fee balance for the quote token.\n     * @return base The current fee balance for the base token.\n     */\n    function getFeeBalance() external view returns (uint128 quote, uint128 base);\n\n    /**\n     * @notice Returns the amount of tokens that can be collected by the host.\n     * @param token The address of the token to be collected.\n     * @return The amount of tokens that can be collected by the host.\n     */\n    function uncollectedHostFees(address token) external view returns (uint256);\n\n    /**\n     * @notice Returns the amount of tokens that can be collected by the dao treasury.\n     * @param token The address of the token to be collected.\n     * @return The amount of tokens that can be collected by the dao treasury.\n     */\n    function uncollectedProtocolFees(address token) external view returns (uint256);\n\n    /**\n     * @notice Returns whether the order book is empty or not.\n     * @param isBid The flag to choose which side to check the emptiness of.\n     * @return Whether the order book is empty or not on that side.\n     */\n    function isEmpty(bool isBid) external view returns (bool);\n\n    /**\n     * @notice Returns the order information.\n     * @param orderKey The order key of the order.\n     * @return The order struct of the given order key.\n     */\n    function getOrder(OrderKey calldata orderKey) external view returns (Order memory);\n\n    /**\n     * @notice Returns the lowest ask price index or the highest bid price index.\n     * @param isBid Returns the lowest ask price if false, highest bid price if true.\n     * @return The current price index. If the order book is empty, it will revert.\n     */\n    function bestPriceIndex(bool isBid) external view returns (uint16);\n\n    /**\n     * @notice Returns the current block trade log index.\n     * @return The current block trade log index.\n     */\n    function blockTradeLogIndex() external view returns (uint16);\n\n    /**\n     * @notice Returns the block trade log for a certain index.\n     * @param index The block trade log index used to query the block trade log.\n     * @return The queried block trade log.\n     */\n    function blockTradeLogs(uint16 index) external view returns (BlockTradeLog memory);\n\n    /**\n     * @notice Converts a raw amount to its corresponding base amount using a given price index.\n     * @param rawAmount The raw amount to be converted.\n     * @param priceIndex The index of the price to be used for the conversion.\n     * @param roundingUp Specifies whether the result should be rounded up or down.\n     * @return The converted base amount.\n     */\n    function rawToBase(uint64 rawAmount, uint16 priceIndex, bool roundingUp) external view returns (uint256);\n\n    /**\n     * @notice Converts a raw amount to its corresponding quote amount.\n     * @param rawAmount The raw amount to be converted.\n     * @return The converted quote amount.\n     */\n    function rawToQuote(uint64 rawAmount) external view returns (uint256);\n\n    /**\n     * @notice Converts a base amount to its corresponding raw amount using a given price index.\n     * @param baseAmount The base amount to be converted.\n     * @param priceIndex The index of the price to be used for the conversion.\n     * @param roundingUp Specifies whether the result should be rounded up or down.\n     * @return The converted raw amount.\n     */\n    function baseToRaw(uint256 baseAmount, uint16 priceIndex, bool roundingUp) external view returns (uint64);\n\n    /**\n     * @notice Converts a quote amount to its corresponding raw amount.\n     * @param quoteAmount The quote amount to be converted.\n     * @param roundingUp Specifies whether the result should be rounded up or down.\n     * @return The converted raw amount.\n     */\n    function quoteToRaw(uint256 quoteAmount, bool roundingUp) external view returns (uint64);\n\n    /**\n     * @notice Collects fees for either the protocol or host.\n     * @param token The token address to collect. It should be the quote token or the base token.\n     * @param destination The destination address to transfer fees.\n     * It should be the dao treasury address or the host address.\n     */\n    function collectFees(address token, address destination) external;\n\n    /**\n     * @notice Change the owner of the order.\n     * @dev Only the OrderToken contract can call this function.\n     * @param orderKey The order key of the order.\n     * @param newOwner The new owner address.\n     */\n    function changeOrderOwner(OrderKey calldata orderKey, address newOwner) external;\n\n    /**\n     * @notice Converts the price index into the actual price.\n     * @param priceIndex The price book index.\n     * @return price The actual price.\n     */\n    function indexToPrice(uint16 priceIndex) external view returns (uint256);\n\n    /**\n     * @notice Returns the price book index closest to the provided price.\n     * @param price Provided price.\n     * @param roundingUp Determines whether to round up or down.\n     * @return index The price book index.\n     * @return correctedPrice The actual price for the price book index.\n     */\n    function priceToIndex(uint256 price, bool roundingUp)\n        external\n        view\n        returns (uint16 index, uint256 correctedPrice);\n}\n"
    },
    "contracts/external/clober/CloberOrderKey.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\n/**\n * @notice A struct that represents a unique key for an order.\n * @param isBid The flag indicating whether it's a bid order or an ask order.\n * @param priceIndex The price book index.\n * @param orderIndex The order index.\n */\nstruct OrderKey {\n    bool isBid;\n    uint16 priceIndex;\n    uint256 orderIndex;\n}\n"
    },
    "contracts/external/eip2470/ISingletonFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ninterface ISingletonFactory {\n    function deploy(bytes calldata initCode, bytes32 salt) external returns (address payable);\n}\n"
    },
    "contracts/external/uniswap-v3/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport {IUniswapV3SwapCallback} from \"./IUniswapV3SwapCallback.sol\";\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/external/uniswap-v3/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n"
    },
    "contracts/external/weth/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IWETH9 is IERC20Metadata {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/external/wrapped1155/IWrapped1155Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\n\n// @author Gnosis (https://github.com/gnosis/1155-to-20)\ninterface IWrapped1155Factory is IERC1155Receiver {\n    function erc20Implementation() external view returns (address);\n\n    function unwrap(address multiToken, uint256 tokenId, uint256 amount, address recipient, bytes calldata data)\n        external;\n\n    function batchUnwrap(\n        address multiToken,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts,\n        address recipient,\n        bytes calldata data\n    ) external;\n\n    function getWrapped1155DeployBytecode(address multiToken, uint256 tokenId, bytes calldata data)\n        external\n        view\n        returns (bytes memory);\n\n    function getWrapped1155(address multiToken, uint256 tokenId, bytes calldata data) external view returns (address);\n\n    function requireWrapped1155(address multiToken, uint256 tokenId, bytes calldata data) external returns (address);\n}\n"
    },
    "contracts/interfaces/IAaveTokenSubstitute.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {ISubstitute} from \"./ISubstitute.sol\";\n\ninterface IAaveTokenSubstitute is ISubstitute {\n    function aToken() external view returns (address);\n\n    function mintByAToken(uint256 amount, address to) external;\n\n    function burnToAToken(uint256 amount, address to) external;\n}\n"
    },
    "contracts/interfaces/IAssetPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ninterface IAssetPool {\n    function isOperator(address operator) external view returns (bool);\n\n    function withdraw(address asset, uint256 amount, address recipient) external;\n}\n"
    },
    "contracts/interfaces/IBondPositionCallbackReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {Coupon} from \"../libraries/Coupon.sol\";\nimport {BondPosition} from \"../libraries/BondPosition.sol\";\n\ninterface IBondPositionCallbackReceiver {\n    function bondPositionAdjustCallback(\n        uint256 tokenId,\n        BondPosition memory oldPosition,\n        BondPosition memory newPosition,\n        Coupon[] memory couponsMinted,\n        Coupon[] memory couponsToBurn,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/IBondPositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IPositionManagerTypes, IPositionManager} from \"./IPositionManager.sol\";\nimport {Epoch} from \"../libraries/Epoch.sol\";\nimport {Coupon} from \"../libraries/Coupon.sol\";\nimport {BondPosition} from \"../libraries/BondPosition.sol\";\n\ninterface IBondPositionManagerTypes is IPositionManagerTypes {\n    event AssetRegistered(address indexed asset);\n    event PositionUpdated(uint256 indexed tokenId, uint256 amount, Epoch expiredWith);\n\n    error InvalidAccess();\n    error UnregisteredAsset();\n    error InvalidEpoch();\n    error AlreadyExpired();\n}\n\ninterface IBondPositionManager is IBondPositionManagerTypes, IPositionManager {\n    // View Functions //\n    function getMaxEpoch() external view returns (Epoch maxEpoch);\n\n    function getPosition(uint256 tokenId) external view returns (BondPosition memory);\n\n    function isAssetRegistered(address asset) external view returns (bool);\n\n    // User Functions //\n    function mint(address asset) external returns (uint256 positionId);\n\n    function adjustPosition(uint256 tokenId, uint256 amount, Epoch expiredWith)\n        external\n        returns (Coupon[] memory couponsToMint, Coupon[] memory couponsToBurn, int256 amountDelta);\n\n    // Admin Functions //\n    function registerAsset(address asset) external;\n}\n"
    },
    "contracts/interfaces/IBorrowController.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {PermitParams} from \"../libraries/PermitParams.sol\";\n\ninterface IBorrowController {\n    error CollateralSwapFailed(string reason);\n    error InvalidDebtAmount();\n\n    function borrow(\n        address collateralToken,\n        address debtToken,\n        uint256 collateralAmount,\n        uint256 borrowAmount,\n        uint256 maxPayInterest,\n        uint8 loanEpochs,\n        PermitParams calldata collateralPermitParams\n    ) external payable;\n\n    function borrowMore(\n        uint256 positionId,\n        uint256 amount,\n        uint256 maxPayInterest,\n        PermitParams calldata positionPermitParams\n    ) external;\n\n    function addCollateral(\n        uint256 positionId,\n        uint256 amount,\n        PermitParams calldata positionPermitParams,\n        PermitParams calldata collateralPermitParams\n    ) external payable;\n\n    function removeCollateral(uint256 positionId, uint256 amount, PermitParams calldata positionPermitParams)\n        external;\n\n    function extendLoanDuration(\n        uint256 positionId,\n        uint8 epochs,\n        uint256 maxPayInterest,\n        PermitParams calldata positionPermitParams,\n        PermitParams calldata debtPermitParams\n    ) external payable;\n\n    function shortenLoanDuration(\n        uint256 positionId,\n        uint8 epochs,\n        uint256 minEarnInterest,\n        PermitParams calldata positionPermitParams\n    ) external;\n\n    function repay(\n        uint256 positionId,\n        uint256 amount,\n        uint256 minEarnInterest,\n        PermitParams calldata positionPermitParams,\n        PermitParams calldata debtPermitParams\n    ) external payable;\n\n    struct SwapData {\n        address swap;\n        uint256 inAmount;\n        uint256 minOutAmount;\n        bytes data;\n    }\n\n    function repayWithCollateral(\n        uint256 positionId,\n        uint256 maxDebtAmount,\n        SwapData calldata swapData,\n        PermitParams calldata positionPermitParams\n    ) external;\n}\n"
    },
    "contracts/interfaces/ICouponManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IERC1155MetadataURI} from \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\n\nimport {CouponKey} from \"../libraries/CouponKey.sol\";\nimport {Coupon} from \"../libraries/Coupon.sol\";\nimport {Epoch} from \"../libraries/Epoch.sol\";\n\ninterface ICouponManager is IERC1155MetadataURI {\n    error InvalidAccess();\n\n    // View Functions //\n    function isMinter(address account) external view returns (bool);\n\n    function currentEpoch() external view returns (Epoch);\n\n    function epochEndTime(Epoch epoch) external pure returns (uint256);\n\n    function baseURI() external view returns (string memory);\n\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    function exists(uint256 id) external view returns (bool);\n\n    // User Functions\n    function safeBatchTransferFrom(address from, address to, Coupon[] calldata coupons, bytes calldata data) external;\n\n    function burnExpiredCoupons(CouponKey[] calldata couponKeys) external;\n\n    // Admin Functions //\n    function mintBatch(address to, Coupon[] calldata coupons, bytes memory data) external;\n\n    function burnBatch(address user, Coupon[] calldata coupons) external;\n}\n"
    },
    "contracts/interfaces/ICouponOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ninterface ICouponOracle {\n    error LengthMismatch();\n    error InvalidDecimals();\n\n    function decimals() external view returns (uint8);\n\n    function fallbackOracle() external view returns (address);\n\n    function getFeed(address asset) external view returns (address);\n\n    function getAssetPrice(address asset) external view returns (uint256);\n\n    function getAssetsPrices(address[] calldata assets) external view returns (uint256[] memory);\n\n    function setFallbackOracle(address newFallbackOracle) external;\n\n    function setFeeds(address[] memory assets, address[] memory feeds) external;\n}\n"
    },
    "contracts/interfaces/IDepositController.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {PermitParams} from \"../libraries/PermitParams.sol\";\n\ninterface IDepositController {\n    function deposit(\n        address token,\n        uint256 amount,\n        uint8 lockEpochs,\n        uint256 minEarnInterest,\n        PermitParams calldata tokenPermitParams\n    ) external payable;\n\n    function withdraw(\n        uint256 positionId,\n        uint256 withdrawAmount,\n        uint256 maxPayInterest,\n        PermitParams calldata positionPermitParams\n    ) external;\n\n    function collect(uint256 positionId, PermitParams calldata positionPermitParams) external;\n}\n"
    },
    "contracts/interfaces/IERC1155Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\ninterface IERC1155Permit is IERC1155 {\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function permit(address owner, address operator, bool approved, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n\n    function nonces(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IERC721} from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ninterface IERC721Permit is IERC721 {\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n        payable;\n\n    function nonces(uint256 tokenId) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IFallbackOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ninterface IFallbackOracle {\n    function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ILoanPositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IPositionManagerTypes, IPositionManager} from \"./IPositionManager.sol\";\nimport {CouponKey} from \"../libraries/CouponKey.sol\";\nimport {Coupon} from \"../libraries/Coupon.sol\";\nimport {Epoch} from \"../libraries/Epoch.sol\";\nimport {LoanPosition} from \"../libraries/LoanPosition.sol\";\n\ninterface ILoanPositionManagerTypes is IPositionManagerTypes {\n    // liquidationFee = liquidator fee + protocol fee\n    // debt = collateral * (1 - liquidationFee)\n    struct LoanConfiguration {\n        uint32 collateralDecimal;\n        uint32 debtDecimal;\n        uint32 liquidationThreshold;\n        uint32 liquidationFee;\n        uint32 liquidationProtocolFee;\n        uint32 liquidationTargetLtv;\n    }\n\n    event AssetRegistered(address indexed asset);\n    event PositionUpdated(uint256 indexed positionId, uint256 collateralAmount, uint256 debtAmount, Epoch unlockedAt);\n    // todo: should give more information\n    event PositionLiquidated(uint256 indexed positionId);\n\n    error AlreadyExpired();\n    error TooSmallDebt();\n    error InvalidAccess();\n    error UnpaidDebt();\n    error LiquidationThreshold();\n    error InvalidPair();\n    error UnableToLiquidate();\n}\n\ninterface ILoanPositionManager is ILoanPositionManagerTypes, IPositionManager {\n    function treasury() external view returns (address);\n\n    function oracle() external view returns (address);\n\n    function minDebtValueInEth() external view returns (uint256);\n\n    function getPosition(uint256 positionId) external view returns (LoanPosition memory);\n\n    function isPairRegistered(address collateral, address debt) external view returns (bool);\n\n    function getLoanConfiguration(address collateral, address debt) external view returns (LoanConfiguration memory);\n\n    function getOwedCouponAmount(address user, uint256 couponId) external view returns (uint256);\n\n    function getLiquidationStatus(uint256 positionId, uint256 maxRepayAmount)\n        external\n        view\n        returns (uint256 liquidationAmount, uint256 repayAmount, uint256 protocolFeeAmount);\n\n    function mint(address collateralToken, address debtToken) external returns (uint256 positionId);\n\n    function adjustPosition(uint256 positionId, uint256 collateralAmount, uint256 debtAmount, Epoch expiredWith)\n        external\n        returns (\n            Coupon[] memory couponsToPay,\n            Coupon[] memory couponsToRefund,\n            int256 collateralDelta,\n            int256 debtDelta\n        );\n\n    function liquidate(uint256 positionId, uint256 maxRepayAmount)\n        external\n        returns (uint256 liquidationAmount, uint256 repayAmount, uint256 protocolFeeAmount);\n\n    function claimOwedCoupons(CouponKey[] memory couponKeys, bytes calldata data) external;\n\n    function setLoanConfiguration(\n        address collateral,\n        address debt,\n        uint32 liquidationThreshold,\n        uint32 liquidationFee,\n        uint32 liquidationProtocolFee,\n        uint32 liquidationTargetLtv\n    ) external;\n}\n"
    },
    "contracts/interfaces/IPositionLocker.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ninterface IPositionLocker {\n    function positionLockAcquired(bytes calldata data) external returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/IPositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport {IERC721Permit} from \"./IERC721Permit.sol\";\nimport {Coupon} from \"../libraries/Coupon.sol\";\n\ninterface IPositionManagerTypes {\n    error LockedBy(address locker);\n    error NotSettled();\n}\n\ninterface IPositionManager is IERC721Metadata, IERC721Permit, IPositionManagerTypes {\n    function baseURI() external view returns (string memory);\n\n    function nextId() external view returns (uint256);\n\n    function assetPool() external view returns (address);\n\n    function lockData() external view returns (uint128, uint128);\n\n    function assetDelta(address locker, uint256 assetId) external view returns (int256);\n\n    function lock(bytes calldata data) external returns (bytes memory);\n\n    function settlePosition(uint256 positionId) external;\n\n    function withdrawToken(address token, address to, uint256 amount) external;\n\n    function mintCoupons(Coupon[] calldata coupons, address to, bytes calldata data) external;\n\n    function depositToken(address token, uint256 amount) external;\n\n    function burnCoupons(Coupon[] calldata coupons) external;\n}\n"
    },
    "contracts/interfaces/ISubstitute.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\ninterface ISubstitute {\n    function treasury() external view returns (address);\n\n    function underlyingToken() external view returns (address);\n\n    function mint(uint256 amount, address to) external;\n\n    function burn(uint256 amount, address to) external;\n\n    function claim() external;\n\n    function mintableAmount() external view returns (uint256);\n\n    function burnableAmount() external view returns (uint256);\n\n    function setTreasury(address newTreasury) external;\n}\n"
    },
    "contracts/libraries/BondPosition.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {Epoch, EpochLibrary} from \"./Epoch.sol\";\nimport {Coupon, CouponLibrary} from \"./Coupon.sol\";\n\nstruct BondPosition {\n    address asset;\n    uint64 nonce;\n    Epoch expiredWith;\n    bool isSettled;\n    uint256 amount;\n}\n\nlibrary BondPositionLibrary {\n    error UnmatchedPosition();\n    error InvalidPositionEpoch();\n\n    using EpochLibrary for Epoch;\n\n    function getAndIncrementNonce(BondPosition storage positionStorage) internal returns (uint64 nonce) {\n        nonce = positionStorage.nonce++;\n    }\n\n    function calculateCouponRequirement(BondPosition memory oldPosition, BondPosition memory newPosition)\n        internal\n        view\n        returns (Coupon[] memory, Coupon[] memory)\n    {\n        if (!(oldPosition.asset == newPosition.asset && oldPosition.nonce == newPosition.nonce)) {\n            revert UnmatchedPosition();\n        }\n\n        Epoch latestExpiredEpoch = EpochLibrary.lastExpiredEpoch();\n        if (latestExpiredEpoch > newPosition.expiredWith || latestExpiredEpoch > oldPosition.expiredWith) {\n            revert InvalidPositionEpoch();\n        }\n        uint256 mintCouponsLength = newPosition.expiredWith.sub(latestExpiredEpoch);\n        uint256 burnCouponsLength = oldPosition.expiredWith.sub(latestExpiredEpoch);\n        unchecked {\n            uint256 minCount = Math.min(mintCouponsLength, burnCouponsLength);\n            if (newPosition.amount > oldPosition.amount) {\n                burnCouponsLength -= minCount;\n            } else if (newPosition.amount < oldPosition.amount) {\n                mintCouponsLength -= minCount;\n            } else {\n                mintCouponsLength -= minCount;\n                burnCouponsLength -= minCount;\n            }\n        }\n\n        Coupon[] memory mintCoupons = new Coupon[](mintCouponsLength);\n        Coupon[] memory burnCoupons = new Coupon[](burnCouponsLength);\n        mintCouponsLength = 0;\n        burnCouponsLength = 0;\n        uint256 farthestExpiredEpochs = newPosition.expiredWith.max(oldPosition.expiredWith).sub(latestExpiredEpoch);\n        unchecked {\n            Epoch epoch = latestExpiredEpoch;\n            for (uint256 i = 0; i < farthestExpiredEpochs; ++i) {\n                epoch = epoch.add(1);\n                uint256 newAmount = newPosition.expiredWith < epoch ? 0 : newPosition.amount;\n                uint256 oldAmount = oldPosition.expiredWith < epoch ? 0 : oldPosition.amount;\n                if (newAmount > oldAmount) {\n                    mintCoupons[mintCouponsLength++] =\n                        CouponLibrary.from(oldPosition.asset, epoch, newAmount - oldAmount);\n                } else if (newAmount < oldAmount) {\n                    burnCoupons[burnCouponsLength++] =\n                        CouponLibrary.from(oldPosition.asset, epoch, oldAmount - newAmount);\n                }\n            }\n        }\n        return (mintCoupons, burnCoupons);\n    }\n}\n"
    },
    "contracts/libraries/Controller.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {CloberMarketSwapCallbackReceiver} from \"../external/clober/CloberMarketSwapCallbackReceiver.sol\";\nimport {CloberMarketFactory} from \"../external/clober/CloberMarketFactory.sol\";\nimport {IWETH9} from \"../external/weth/IWETH9.sol\";\nimport {IWrapped1155Factory} from \"../external/wrapped1155/IWrapped1155Factory.sol\";\nimport {CloberOrderBook} from \"../external/clober/CloberOrderBook.sol\";\nimport {ICouponManager} from \"../interfaces/ICouponManager.sol\";\nimport {PermitParams, PermitParamsLibrary} from \"./PermitParams.sol\";\nimport {Coupon, CouponLibrary} from \"./Coupon.sol\";\nimport {CouponKey, CouponKeyLibrary} from \"./CouponKey.sol\";\nimport {Wrapped1155MetadataBuilder} from \"./Wrapped1155MetadataBuilder.sol\";\nimport {IERC721Permit} from \"../interfaces/IERC721Permit.sol\";\nimport {ISubstitute} from \"../interfaces/ISubstitute.sol\";\nimport {IAaveTokenSubstitute} from \"../interfaces/IAaveTokenSubstitute.sol\";\nimport {ReentrancyGuard} from \"./ReentrancyGuard.sol\";\n\nabstract contract Controller is ERC1155Holder, CloberMarketSwapCallbackReceiver, Ownable, ReentrancyGuard {\n    error ValueTransferFailed();\n    error InvalidAccess();\n    error InvalidMarket();\n    error ControllerSlippage();\n\n    using SafeERC20 for IERC20;\n    using PermitParamsLibrary for PermitParams;\n    using CouponKeyLibrary for CouponKey;\n    using CouponLibrary for Coupon;\n\n    IWrapped1155Factory internal immutable _wrapped1155Factory;\n    CloberMarketFactory internal immutable _cloberMarketFactory;\n    ICouponManager internal immutable _couponManager;\n    IWETH9 internal immutable _weth;\n\n    mapping(uint256 couponId => address market) internal _couponMarkets;\n\n    constructor(address wrapped1155Factory, address cloberMarketFactory, address couponManager, address weth) {\n        _wrapped1155Factory = IWrapped1155Factory(wrapped1155Factory);\n        _cloberMarketFactory = CloberMarketFactory(cloberMarketFactory);\n        _couponManager = ICouponManager(couponManager);\n        _weth = IWETH9(weth);\n    }\n\n    modifier wrapETH() {\n        if (msg.value > 0) {\n            _weth.deposit{value: msg.value}();\n        }\n        _;\n    }\n\n    function _executeCouponTrade(\n        address user,\n        address token,\n        Coupon[] memory couponsToBuy,\n        Coupon[] memory couponsToSell,\n        uint256 amountToPay,\n        uint256 maxPayInterest,\n        uint256 leftRequiredInterest\n    ) internal {\n        if (couponsToBuy.length > 0) {\n            Coupon memory lastCoupon = couponsToBuy[couponsToBuy.length - 1];\n            assembly {\n                mstore(couponsToBuy, sub(mload(couponsToBuy), 1))\n            }\n            bytes memory data =\n                abi.encode(user, couponsToBuy, new Coupon[](0), amountToPay, maxPayInterest, leftRequiredInterest);\n            assembly {\n                mstore(couponsToBuy, add(mload(couponsToBuy), 1))\n            }\n\n            CloberOrderBook market = CloberOrderBook(_couponMarkets[lastCoupon.id()]);\n            uint256 dy = lastCoupon.amount - IERC20(market.baseToken()).balanceOf(address(this));\n            market.marketOrder(address(this), type(uint16).max, type(uint64).max, dy, 1, data);\n        } else if (couponsToSell.length > 0) {\n            Coupon memory lastCoupon = couponsToSell[couponsToSell.length - 1];\n            assembly {\n                mstore(couponsToSell, sub(mload(couponsToSell), 1))\n            }\n            bytes memory data =\n                abi.encode(user, new Coupon[](0), couponsToSell, amountToPay, maxPayInterest, leftRequiredInterest);\n            assembly {\n                mstore(couponsToSell, add(mload(couponsToSell), 1))\n            }\n\n            CloberOrderBook market = CloberOrderBook(_couponMarkets[lastCoupon.id()]);\n            market.marketOrder(address(this), 0, 0, lastCoupon.amount, 2, data);\n        } else {\n            if (leftRequiredInterest > 0) revert ControllerSlippage();\n            _ensureBalance(token, user, amountToPay);\n        }\n    }\n\n    function cloberMarketSwapCallback(\n        address inputToken,\n        address,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes calldata data\n    ) external payable {\n        // check if caller is registered market\n        if (_cloberMarketFactory.getMarketHost(msg.sender) == address(0)) revert InvalidAccess();\n\n        (\n            address user,\n            Coupon[] memory buyCoupons,\n            Coupon[] memory sellCoupons,\n            uint256 amountToPay,\n            uint256 maxPayInterest,\n            uint256 leftRequiredInterest\n        ) = abi.decode(data, (address, Coupon[], Coupon[], uint256, uint256, uint256));\n\n        address asset = CloberOrderBook(msg.sender).quoteToken();\n        if (asset == inputToken) {\n            if (maxPayInterest < inputAmount) revert ControllerSlippage();\n            maxPayInterest -= inputAmount;\n            amountToPay += inputAmount;\n        } else {\n            if (leftRequiredInterest > outputAmount) {\n                leftRequiredInterest -= outputAmount;\n            } else {\n                leftRequiredInterest = 0;\n            }\n        }\n\n        _executeCouponTrade(user, asset, buyCoupons, sellCoupons, amountToPay, maxPayInterest, leftRequiredInterest);\n\n        // transfer input tokens\n        if (inputAmount > 0) {\n            IERC20(inputToken).safeTransfer(msg.sender, inputAmount);\n        }\n    }\n\n    function _permitERC20(address token, uint256 amount, PermitParams calldata p) internal {\n        if (!p.isEmpty()) {\n            IERC20Permit(ISubstitute(token).underlyingToken()).permit(\n                msg.sender, address(this), amount, p.deadline, p.v, p.r, p.s\n            );\n        }\n    }\n\n    function _permitERC721(IERC721Permit permitNFT, uint256 positionId, PermitParams calldata p) internal {\n        if (!p.isEmpty()) {\n            permitNFT.permit(address(this), positionId, p.deadline, p.v, p.r, p.s);\n        }\n    }\n\n    function _burnAllSubstitute(address substitute, address to) internal {\n        uint256 leftAmount = IERC20(substitute).balanceOf(address(this));\n        if (leftAmount == 0) return;\n\n        address underlyingToken = ISubstitute(substitute).underlyingToken();\n        uint256 burnableAmount = ISubstitute(substitute).burnableAmount();\n        if (burnableAmount < leftAmount) {\n            IAaveTokenSubstitute(substitute).burnToAToken(leftAmount - burnableAmount, to);\n            leftAmount = burnableAmount;\n        }\n        if (underlyingToken == address(_weth)) {\n            ISubstitute(substitute).burn(leftAmount, address(this));\n            _weth.withdraw(leftAmount);\n            (bool success,) = payable(to).call{value: leftAmount}(\"\");\n            if (!success) revert ValueTransferFailed();\n        } else {\n            ISubstitute(substitute).burn(leftAmount, to);\n        }\n    }\n\n    function _ensureBalance(address token, address user, uint256 amount) internal {\n        address underlyingToken = ISubstitute(token).underlyingToken();\n        uint256 thisBalance = IERC20(token).balanceOf(address(this));\n        uint256 underlyingBalance = IERC20(underlyingToken).balanceOf(address(this));\n        if (amount > thisBalance + underlyingBalance) {\n            unchecked {\n                IERC20(underlyingToken).safeTransferFrom(user, address(this), amount - thisBalance - underlyingBalance);\n                underlyingBalance = amount - thisBalance;\n            }\n        }\n        if (underlyingBalance > 0) {\n            IERC20(underlyingToken).approve(token, underlyingBalance);\n            ISubstitute(token).mint(underlyingBalance, address(this));\n        }\n    }\n\n    function _wrapCoupons(Coupon[] memory coupons) internal {\n        // wrap 1155 to 20\n        _couponManager.safeBatchTransferFrom(\n            address(this),\n            address(_wrapped1155Factory),\n            coupons,\n            Wrapped1155MetadataBuilder.buildWrapped1155BatchMetadata(coupons)\n        );\n    }\n\n    function _unwrapCoupons(Coupon[] memory coupons) internal {\n        if (coupons.length > 0) {\n            uint256[] memory tokenIds = new uint256[](coupons.length);\n            uint256[] memory amounts = new uint256[](coupons.length);\n            for (uint256 i = 0; i < coupons.length; i++) {\n                tokenIds[i] = coupons[i].id();\n                amounts[i] = coupons[i].amount;\n            }\n            _wrapped1155Factory.batchUnwrap(\n                address(_couponManager),\n                tokenIds,\n                amounts,\n                address(this),\n                Wrapped1155MetadataBuilder.buildWrapped1155BatchMetadata(coupons)\n            );\n        }\n    }\n\n    function getCouponMarket(CouponKey memory couponKey) external view returns (address) {\n        return _couponMarkets[couponKey.toId()];\n    }\n\n    function setCouponMarket(CouponKey memory couponKey, address cloberMarket) public virtual onlyOwner {\n        bytes memory wrappedCouponMetadata = Wrapped1155MetadataBuilder.buildWrapped1155Metadata(couponKey);\n        uint256 id = couponKey.toId();\n        address wrappedCoupon = _wrapped1155Factory.getWrapped1155(address(_couponManager), id, wrappedCouponMetadata);\n        CloberMarketFactory.MarketInfo memory marketInfo = _cloberMarketFactory.getMarketInfo(cloberMarket);\n        if (marketInfo.host == address(0)) revert InvalidMarket();\n        if (CloberOrderBook(cloberMarket).baseToken() != wrappedCoupon) revert InvalidMarket();\n        if (CloberOrderBook(cloberMarket).quoteToken() != couponKey.asset) revert InvalidMarket();\n        _couponMarkets[id] = cloberMarket;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/libraries/Coupon.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {Epoch} from \"../libraries/Epoch.sol\";\nimport {CouponKey, CouponKeyLibrary} from \"./CouponKey.sol\";\n\nstruct Coupon {\n    CouponKey key;\n    uint256 amount;\n}\n\nlibrary CouponLibrary {\n    using CouponKeyLibrary for CouponKey;\n\n    function from(address asset, Epoch epoch, uint256 amount) internal pure returns (Coupon memory) {\n        return Coupon({key: CouponKey({asset: asset, epoch: epoch}), amount: amount});\n    }\n\n    function from(CouponKey memory couponKey, uint256 amount) internal pure returns (Coupon memory) {\n        return Coupon({key: couponKey, amount: amount});\n    }\n\n    function id(Coupon memory coupon) internal pure returns (uint256) {\n        return coupon.key.toId();\n    }\n}\n"
    },
    "contracts/libraries/CouponKey.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {Epoch} from \"./Epoch.sol\";\n\nstruct CouponKey {\n    address asset;\n    Epoch epoch;\n}\n\nlibrary CouponKeyLibrary {\n    function toId(CouponKey memory key) internal pure returns (uint256 id) {\n        uint8 epoch = Epoch.unwrap(key.epoch);\n        address asset = key.asset;\n        assembly {\n            id := add(asset, shl(160, epoch))\n        }\n    }\n}\n"
    },
    "contracts/libraries/Epoch.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\ntype Epoch is uint8;\n\nusing {gt as >, gte as >=, lt as <, lte as <=, eq as ==} for Epoch global;\n\nfunction gt(Epoch a, Epoch b) pure returns (bool) {\n    return Epoch.unwrap(a) > Epoch.unwrap(b);\n}\n\nfunction gte(Epoch a, Epoch b) pure returns (bool) {\n    return Epoch.unwrap(a) >= Epoch.unwrap(b);\n}\n\nfunction lt(Epoch a, Epoch b) pure returns (bool) {\n    return Epoch.unwrap(a) < Epoch.unwrap(b);\n}\n\nfunction lte(Epoch a, Epoch b) pure returns (bool) {\n    return Epoch.unwrap(a) <= Epoch.unwrap(b);\n}\n\nfunction eq(Epoch a, Epoch b) pure returns (bool) {\n    return Epoch.unwrap(a) == Epoch.unwrap(b);\n}\n\nlibrary EpochLibrary {\n    using EpochLibrary for Epoch;\n\n    error EpochOverflow();\n\n    uint256 internal constant MONTHS_PER_EPOCH = 6;\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    function wrap(uint8 epoch) internal pure returns (Epoch) {\n        return Epoch.wrap(epoch);\n    }\n\n    function unwrap(Epoch epoch) internal pure returns (uint8) {\n        return Epoch.unwrap(epoch);\n    }\n\n    function startTime(Epoch epoch) internal pure returns (uint256) {\n        uint8 currentEpoch = Epoch.unwrap(epoch);\n        if (currentEpoch == 0) return 0;\n        unchecked {\n            return _epochToTimestamp(currentEpoch - 1);\n        }\n    }\n\n    function endTime(Epoch epoch) internal pure returns (uint256) {\n        return _epochToTimestamp(Epoch.unwrap(epoch));\n    }\n\n    function isExpired(Epoch epoch) internal view returns (bool) {\n        return endTime(epoch) <= block.timestamp;\n    }\n\n    function lastExpiredEpoch() internal view returns (Epoch) {\n        return current().sub(1);\n    }\n\n    function current() internal view returns (Epoch) {\n        return Epoch.wrap(_timestampToEpoch(block.timestamp));\n    }\n\n    function long(Epoch epoch) internal pure returns (uint256) {\n        unchecked {\n            return endTime(epoch) - startTime(epoch);\n        }\n    }\n\n    function add(Epoch epoch, uint8 epochs) internal pure returns (Epoch) {\n        return Epoch.wrap(Epoch.unwrap(epoch) + epochs);\n    }\n\n    function sub(Epoch epoch, uint8 epochs) internal pure returns (Epoch) {\n        return Epoch.wrap(Epoch.unwrap(epoch) - epochs);\n    }\n\n    function sub(Epoch e1, Epoch e2) internal pure returns (uint8) {\n        return Epoch.unwrap(e1) - Epoch.unwrap(e2);\n    }\n\n    function max(Epoch a, Epoch b) internal pure returns (Epoch) {\n        return a > b ? a : b;\n    }\n\n    // Inspired by https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _timestampToEpoch(uint256 timestamp) private pure returns (uint8) {\n        unchecked {\n            uint256 _days = timestamp / SECONDS_PER_DAY;\n            int256 __days = int256(_days);\n\n            int256 L = __days + 68569 + OFFSET19700101;\n            int256 N = (4 * L) / 146097;\n            L = L - (146097 * N + 3) / 4;\n            int256 _year = (4000 * (L + 1)) / 1461001;\n            L = L - (1461 * _year) / 4 + 31;\n            int256 _month = (80 * L) / 2447;\n            L = _month / 11;\n            _month = _month + 2 - 12 * L;\n            _year = 100 * (N - 49) + _year + L;\n\n            uint256 epoch = uint256((_year - 1970) * 12 + _month - 1) / MONTHS_PER_EPOCH;\n            if (epoch > type(uint8).max) revert EpochOverflow();\n            return uint8(epoch);\n        }\n    }\n\n    function _epochToTimestamp(uint8 epoch) internal pure returns (uint256) {\n        unchecked {\n            uint256 months = MONTHS_PER_EPOCH + MONTHS_PER_EPOCH * epoch;\n            uint256 year = months / 12 + 1970;\n            months = (months % 12) << 4;\n            if (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\n                // 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366\n                months = 0x016E014F0131011200F400D500B600980079005B003C001F0000 >> months;\n            } else {\n                // 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365\n                months = 0x016D014E0130011100F300D400B500970078005A003B001F0000 >> months;\n            }\n            return (\n                (months & 0xffff) + 365 * (year - 1970) + (year - 1969) / 4 - (year - 1901) / 100 + (year - 1601) / 400\n            ) * SECONDS_PER_DAY;\n        }\n    }\n}\n"
    },
    "contracts/libraries/ERC1155Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {ERC1155} from \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\nimport {IERC1155Permit} from \"../interfaces/IERC1155Permit.sol\";\n\ncontract ERC1155Permit is ERC1155, IERC1155Permit, EIP712 {\n    error InvalidSignature();\n    error PermitExpired();\n\n    mapping(address => uint256) public override nonces;\n\n    bytes32 public constant override PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\");\n\n    constructor(string memory uri_, string memory name, string memory version) ERC1155(uri_) EIP712(name, version) {}\n\n    function permit(address owner, address operator, bool approved, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n        override\n    {\n        if (block.timestamp > deadline) revert PermitExpired();\n\n        bytes32 structHash;\n        unchecked {\n            structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, operator, approved, nonces[owner]++, deadline));\n        }\n\n        bytes32 digest = _hashTypedDataV4(structHash);\n\n        if (Address.isContract(owner)) {\n            if (IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) != 0x1626ba7e) {\n                revert InvalidSignature();\n            }\n        } else {\n            address signer = ECDSA.recover(digest, v, r, s);\n            if (signer != owner) revert InvalidSignature();\n        }\n\n        _setApprovalForAll(owner, operator, approved);\n    }\n\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC1155, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Permit).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "contracts/libraries/ERC721Permit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n\npragma solidity ^0.8.0;\n\nimport {ERC721} from \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EIP712} from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\n\nimport {IERC721Permit} from \"../interfaces/IERC721Permit.sol\";\n\nabstract contract ERC721Permit is ERC721, IERC721Permit, EIP712 {\n    error InvalidSignature();\n    error PermitExpired();\n\n    // keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH =\n        0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\n\n    constructor(string memory name_, string memory symbol_, string memory version_)\n        ERC721(name_, symbol_)\n        EIP712(name_, version_)\n    {}\n\n    function permit(address spender, uint256 tokenId, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n        payable\n        override\n    {\n        if (block.timestamp > deadline) revert PermitExpired();\n\n        bytes32 structHash =\n            keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, _getAndIncrementNonce(tokenId), deadline));\n        bytes32 digest = _hashTypedDataV4(structHash);\n\n        address owner = ownerOf(tokenId);\n        if (spender == owner) revert InvalidSignature();\n\n        if (Address.isContract(owner)) {\n            if (IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) != 0x1626ba7e) {\n                revert InvalidSignature();\n            }\n        } else {\n            address signer = ECDSA.recover(digest, v, r, s);\n            if (signer != owner) revert InvalidSignature();\n        }\n\n        _approve(spender, tokenId);\n    }\n\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\n        return interfaceId == type(IERC721Permit).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function _getAndIncrementNonce(uint256 tokenId) internal virtual returns (uint256);\n}\n"
    },
    "contracts/libraries/LoanPosition.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {Epoch, EpochLibrary} from \"./Epoch.sol\";\nimport {Coupon, CouponLibrary} from \"./Coupon.sol\";\n\nstruct LoanPosition {\n    uint64 nonce;\n    Epoch expiredWith;\n    bool isSettled;\n    address collateralToken;\n    address debtToken;\n    uint256 collateralAmount;\n    uint256 debtAmount;\n}\n\nlibrary LoanPositionLibrary {\n    error UnmatchedPosition();\n    error InvalidPositionEpoch();\n\n    using EpochLibrary for Epoch;\n\n    function getAndIncrementNonce(LoanPosition storage positionStorage) internal returns (uint64 nonce) {\n        nonce = positionStorage.nonce++;\n    }\n\n    function calculateCouponRequirement(LoanPosition memory oldPosition, LoanPosition memory newPosition)\n        internal\n        view\n        returns (Coupon[] memory, Coupon[] memory)\n    {\n        if (\n            !(\n                oldPosition.collateralToken == newPosition.collateralToken\n                    && oldPosition.debtToken == newPosition.debtToken && oldPosition.nonce == newPosition.nonce\n            )\n        ) revert UnmatchedPosition();\n\n        Epoch latestExpiredEpoch = EpochLibrary.lastExpiredEpoch();\n        if (latestExpiredEpoch > newPosition.expiredWith || latestExpiredEpoch > oldPosition.expiredWith) {\n            revert InvalidPositionEpoch();\n        }\n\n        uint256 payCouponsLength = newPosition.expiredWith.sub(latestExpiredEpoch);\n        uint256 refundCouponsLength = oldPosition.expiredWith.sub(latestExpiredEpoch);\n        unchecked {\n            uint256 minCount = Math.min(payCouponsLength, refundCouponsLength);\n            if (newPosition.debtAmount > oldPosition.debtAmount) {\n                refundCouponsLength -= minCount;\n            } else if (newPosition.debtAmount < oldPosition.debtAmount) {\n                payCouponsLength -= minCount;\n            } else {\n                payCouponsLength -= minCount;\n                refundCouponsLength -= minCount;\n            }\n        }\n\n        Coupon[] memory payCoupons = new Coupon[](payCouponsLength);\n        Coupon[] memory refundCoupons = new Coupon[](refundCouponsLength);\n        payCouponsLength = 0;\n        refundCouponsLength = 0;\n        uint256 farthestExpiredEpochs = newPosition.expiredWith.max(oldPosition.expiredWith).sub(latestExpiredEpoch);\n        unchecked {\n            Epoch epoch = latestExpiredEpoch;\n            for (uint256 i = 0; i < farthestExpiredEpochs; ++i) {\n                epoch = epoch.add(1);\n                uint256 newAmount = newPosition.expiredWith < epoch ? 0 : newPosition.debtAmount;\n                uint256 oldAmount = oldPosition.expiredWith < epoch ? 0 : oldPosition.debtAmount;\n                if (newAmount > oldAmount) {\n                    payCoupons[payCouponsLength++] =\n                        CouponLibrary.from(oldPosition.debtToken, epoch, newAmount - oldAmount);\n                } else if (newAmount < oldAmount) {\n                    refundCoupons[refundCouponsLength++] =\n                        CouponLibrary.from(oldPosition.debtToken, epoch, oldAmount - newAmount);\n                }\n            }\n        }\n        return (payCoupons, refundCoupons);\n    }\n}\n"
    },
    "contracts/libraries/LockData.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.20;\n\n/// @author Coupon Finance\n/// @author Modified from Uniswap V4 (https://github.com/Uniswap/v4-core/tree/98680ebc1a654120e995d53a5b10ec6fe153066f)\n/// @notice Contains data about pool lockers.\nstruct LockData {\n    /// @notice The current number of active lockers\n    uint128 length;\n    /// @notice The total number of nonzero deltas over all active + completed lockers\n    uint128 nonzeroDeltaCount;\n}\n\n/// @dev This library manages a custom storage implementation for a queue\n///      that tracks current lockers. The \"sentinel\" storage slot for this data structure,\n///      always passed in as IPoolManager.LockData storage self, stores not just the current\n///      length of the queue but also the global count of non-zero deltas across all lockers.\n///      The values of the data structure start at OFFSET, and each value is a locker address.\nlibrary LockDataLibrary {\n    uint256 private constant OFFSET = uint256(keccak256(\"LockData\"));\n\n    /// @dev Pushes a locker onto the end of the queue, and updates the sentinel storage slot.\n    function push(LockData storage self, address locker) internal {\n        // read current value from the sentinel storage slot\n        uint128 length = self.length;\n        unchecked {\n            uint256 indexToWrite = OFFSET + length; // not in assembly because OFFSET is in the library scope\n            /// @solidity memory-safe-assembly\n            assembly {\n                // in the next storage slot, write the locker\n                sstore(indexToWrite, locker)\n            }\n            // update the sentinel storage slot\n            self.length = length + 1;\n        }\n    }\n\n    /// @dev Pops a locker off the end of the queue. Note that no storage gets cleared.\n    function pop(LockData storage self) internal {\n        unchecked {\n            self.length--;\n        }\n    }\n\n    function getLock(uint256 i) internal view returns (address locker) {\n        unchecked {\n            uint256 position = OFFSET + i; // not in assembly because OFFSET is in the library scope\n            /// @solidity memory-safe-assembly\n            assembly {\n                locker := sload(position)\n            }\n        }\n    }\n\n    function getActiveLock(LockData storage self) internal view returns (address locker) {\n        return getLock(self.length - 1);\n    }\n}\n"
    },
    "contracts/libraries/PermitParams.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nstruct PermitParams {\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n}\n\nlibrary PermitParamsLibrary {\n    function isEmpty(PermitParams memory params) internal pure returns (bool) {\n        return params.deadline == 0;\n    }\n}\n"
    },
    "contracts/libraries/PositionManager.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport {IAssetPool} from \"../interfaces/IAssetPool.sol\";\nimport {ICouponManager} from \"../interfaces/ICouponManager.sol\";\nimport {IPositionLocker} from \"../interfaces/IPositionLocker.sol\";\nimport {ERC721Permit} from \"./ERC721Permit.sol\";\nimport {LockData, LockDataLibrary} from \"./LockData.sol\";\nimport {Coupon, CouponLibrary} from \"./Coupon.sol\";\nimport {IPositionManager} from \"../interfaces/IPositionManager.sol\";\n\nabstract contract PositionManager is ERC721Permit, IPositionManager {\n    using SafeERC20 for IERC20;\n    using CouponLibrary for Coupon;\n    using LockDataLibrary for LockData;\n\n    address internal immutable _couponManager;\n    address public immutable override assetPool;\n\n    string public override baseURI;\n    uint256 public override nextId = 1;\n\n    LockData private _lockData;\n\n    // @dev Since the epoch is greater than 0, the coupon ID and address can never be the same.\n    mapping(address locker => mapping(uint256 assetId => int256 delta)) public override assetDelta;\n\n    constructor(\n        address couponManager_,\n        address assetPool_,\n        string memory baseURI_,\n        string memory name_,\n        string memory symbol_\n    ) ERC721Permit(name_, symbol_, \"1\") {\n        _couponManager = couponManager_;\n        assetPool = assetPool_;\n        baseURI = baseURI_;\n    }\n\n    modifier modifyPosition(uint256 positionId) {\n        _;\n        _unsettlePosition(positionId);\n    }\n\n    modifier onlyByLocker() {\n        address locker = _lockData.getActiveLock();\n        if (msg.sender != locker) revert LockedBy(locker);\n        _;\n    }\n\n    function lock(bytes calldata data) external returns (bytes memory result) {\n        _lockData.push(msg.sender);\n\n        result = IPositionLocker(msg.sender).positionLockAcquired(data);\n\n        if (_lockData.length == 1) {\n            if (_lockData.nonzeroDeltaCount != 0) revert NotSettled();\n            delete _lockData;\n        } else {\n            _lockData.pop();\n        }\n    }\n\n    function _isSettled(uint256 positionId) internal view virtual returns (bool);\n\n    function _setPositionSettlement(uint256 positionId, bool settled) internal virtual;\n\n    function _unsettlePosition(uint256 positionId) internal {\n        if (!_isSettled(positionId)) return;\n        _setPositionSettlement(positionId, false);\n        unchecked {\n            _lockData.nonzeroDeltaCount++;\n        }\n    }\n\n    function _accountDelta(uint256 assetId, uint256 amount0, uint256 amount1) internal returns (int256 delta) {\n        if (amount0 == amount1) return 0;\n\n        address locker = _lockData.getActiveLock();\n        int256 current = assetDelta[locker][assetId];\n        unchecked {\n            if (amount0 > amount1) {\n                delta = SafeCast.toInt256(amount0 - amount1);\n            } else {\n                delta = -SafeCast.toInt256(amount1 - amount0);\n            }\n        }\n        int256 next = current + delta;\n\n        unchecked {\n            if (next == 0) {\n                _lockData.nonzeroDeltaCount--;\n            } else if (current == 0) {\n                _lockData.nonzeroDeltaCount++;\n            }\n        }\n\n        assetDelta[locker][assetId] = next;\n    }\n\n    function withdrawToken(address token, address to, uint256 amount) external onlyByLocker {\n        _accountDelta(uint256(uint160(token)), amount, 0);\n        IAssetPool(assetPool).withdraw(token, amount, to);\n    }\n\n    function mintCoupons(Coupon[] calldata coupons, address to, bytes calldata data) external onlyByLocker {\n        unchecked {\n            for (uint256 i = 0; i < coupons.length; ++i) {\n                _accountDelta(coupons[i].id(), coupons[i].amount, 0);\n            }\n            ICouponManager(_couponManager).mintBatch(to, coupons, data);\n        }\n    }\n\n    function depositToken(address token, uint256 amount) external onlyByLocker {\n        if (amount == 0) return;\n        IERC20(token).safeTransferFrom(msg.sender, assetPool, amount);\n        _accountDelta(uint256(uint160(token)), 0, amount);\n    }\n\n    function burnCoupons(Coupon[] calldata coupons) external onlyByLocker {\n        unchecked {\n            ICouponManager(_couponManager).burnBatch(msg.sender, coupons);\n            for (uint256 i = 0; i < coupons.length; ++i) {\n                _accountDelta(coupons[i].id(), 0, coupons[i].amount);\n            }\n        }\n    }\n\n    function settlePosition(uint256 positionId) public virtual {\n        if (_isSettled(positionId)) return;\n        _setPositionSettlement(positionId, true);\n        unchecked {\n            _lockData.nonzeroDeltaCount--;\n        }\n    }\n\n    function _baseURI() internal view override returns (string memory) {\n        return baseURI;\n    }\n\n    function lockData() external view override returns (uint128, uint128) {\n        return (_lockData.length, _lockData.nonzeroDeltaCount);\n    }\n\n    function _mint(address to, uint256 positionId) internal virtual override {\n        super._mint(to, positionId);\n        _setPositionSettlement(positionId, false);\n        unchecked {\n            _lockData.nonzeroDeltaCount++;\n        }\n    }\n}\n"
    },
    "contracts/libraries/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\n\npragma solidity >=0.8.0;\n\n/// @notice Gas optimized reentrancy protection for smart contracts.\n/// @author Clober (https://github.com/clober-dex/coupon-finance/blob/main/contracts/libraries/ReentrancyGuard.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\nabstract contract ReentrancyGuard {\n    error Reentrancy();\n\n    uint256 internal _locked = 1;\n\n    modifier nonReentrant() virtual {\n        if (_locked != 1) revert Reentrancy();\n\n        _locked = 2;\n\n        _;\n\n        _locked = 1;\n    }\n}\n"
    },
    "contracts/libraries/Wrapped1155MetadataBuilder.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {CouponKey} from \"./CouponKey.sol\";\nimport {Coupon} from \"./Coupon.sol\";\nimport {Epoch} from \"./Epoch.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nlibrary Wrapped1155MetadataBuilder {\n    function buildWrapped1155Metadata(CouponKey memory couponKey) internal view returns (bytes memory) {\n        string memory tokenSymbol = IERC20Metadata(couponKey.asset).symbol();\n        string memory epochString = Strings.toString(Epoch.unwrap(couponKey.epoch));\n        // @dev assume that tokenSymbol.length <= 12\n        bytes32 nameData = bytes32(abi.encodePacked(tokenSymbol, \" Bond Coupon (\", epochString, \")\"));\n        bytes32 symbolData = bytes32(abi.encodePacked(tokenSymbol, \"-CP\", epochString));\n        assembly {\n            let addLength := mul(2, add(mload(tokenSymbol), mload(epochString)))\n            nameData := add(nameData, add(30, addLength))\n            symbolData := add(symbolData, add(6, addLength))\n        }\n        bytes1 decimal = bytes1(IERC20Metadata(couponKey.asset).decimals());\n        return abi.encodePacked(nameData, symbolData, decimal);\n    }\n\n    function buildWrapped1155BatchMetadata(Coupon[] memory coupons) internal view returns (bytes memory data) {\n        unchecked {\n            data = new bytes(0);\n            for (uint256 i = 0; i < coupons.length; ++i) {\n                data = bytes.concat(data, buildWrapped1155Metadata(coupons[i].key));\n            }\n        }\n    }\n}\n"
    },
    "contracts/LoanPositionManager.sol": {
      "content": "// SPDX-License-Identifier: -\n// License: https://license.clober.io/LICENSE.pdf\n\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {ERC1155Holder, ERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\nimport {IAssetPool} from \"./interfaces/IAssetPool.sol\";\nimport {ICouponOracle} from \"./interfaces/ICouponOracle.sol\";\nimport {ICouponManager} from \"./interfaces/ICouponManager.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {ILoanPositionManager} from \"./interfaces/ILoanPositionManager.sol\";\nimport {ERC721Permit, IERC165} from \"./libraries/ERC721Permit.sol\";\nimport {CouponKey, CouponKeyLibrary} from \"./libraries/CouponKey.sol\";\nimport {Coupon, CouponLibrary} from \"./libraries/Coupon.sol\";\nimport {Epoch, EpochLibrary} from \"./libraries/Epoch.sol\";\nimport {LoanPosition, LoanPositionLibrary} from \"./libraries/LoanPosition.sol\";\nimport {PositionManager} from \"./libraries/PositionManager.sol\";\n\ncontract LoanPositionManager is ILoanPositionManager, PositionManager, Ownable {\n    using LoanPositionLibrary for LoanPosition;\n    using CouponKeyLibrary for CouponKey;\n    using CouponLibrary for Coupon;\n    using EpochLibrary for Epoch;\n\n    uint256 private constant _RATE_PRECISION = 10 ** 6;\n\n    address public immutable override oracle;\n    address public immutable override treasury;\n    uint256 public immutable override minDebtValueInEth;\n\n    mapping(address user => mapping(uint256 couponId => uint256)) private _couponOwed;\n    mapping(bytes32 => LoanConfiguration) private _loanConfiguration;\n    mapping(uint256 id => LoanPosition) private _positionMap;\n\n    constructor(\n        address couponManager_,\n        address assetPool_,\n        address oracle_,\n        address treasury_,\n        uint256 minDebtValueInEth_,\n        string memory baseURI_\n    ) PositionManager(couponManager_, assetPool_, baseURI_, \"Loan Position\", \"LP\") {\n        oracle = oracle_;\n        treasury = treasury_;\n        minDebtValueInEth = minDebtValueInEth_;\n    }\n\n    function getPosition(uint256 positionId) external view returns (LoanPosition memory) {\n        return _positionMap[positionId];\n    }\n\n    function isPairRegistered(address collateral, address debt) external view returns (bool) {\n        return !_isPairUnregistered(collateral, debt);\n    }\n\n    function getOwedCouponAmount(address user, uint256 couponId) external view returns (uint256) {\n        return _couponOwed[user][couponId];\n    }\n\n    function getLoanConfiguration(address collateral, address debt) external view returns (LoanConfiguration memory) {\n        return _loanConfiguration[_buildLoanPairId(collateral, debt)];\n    }\n\n    function mint(address collateralToken, address debtToken) external onlyByLocker returns (uint256 positionId) {\n        if (_isPairUnregistered(collateralToken, debtToken)) {\n            revert InvalidPair();\n        }\n\n        unchecked {\n            positionId = nextId++;\n        }\n        _positionMap[positionId].collateralToken = collateralToken;\n        _positionMap[positionId].debtToken = debtToken;\n\n        _mint(msg.sender, positionId);\n    }\n\n    function adjustPosition(uint256 positionId, uint256 collateralAmount, uint256 debtAmount, Epoch expiredWith)\n        external\n        onlyByLocker\n        modifyPosition(positionId)\n        returns (\n            Coupon[] memory couponsToPay,\n            Coupon[] memory couponsToRefund,\n            int256 collateralDelta,\n            int256 debtDelta\n        )\n    {\n        if (!_isApprovedOrOwner(msg.sender, positionId)) revert InvalidAccess();\n\n        Epoch lastExpiredEpoch = EpochLibrary.lastExpiredEpoch();\n        LoanPosition memory oldPosition = _positionMap[positionId];\n        _positionMap[positionId].collateralAmount = collateralAmount;\n\n        if (Epoch.wrap(0) < oldPosition.expiredWith && oldPosition.expiredWith <= lastExpiredEpoch) {\n            // Only unexpired position can adjust debtAmount\n            if (oldPosition.debtAmount != debtAmount) revert AlreadyExpired();\n        } else {\n            if (oldPosition.expiredWith == Epoch.wrap(0)) {\n                oldPosition.expiredWith = lastExpiredEpoch;\n            }\n            _positionMap[positionId].debtAmount = debtAmount;\n            _positionMap[positionId].expiredWith = debtAmount == 0 ? lastExpiredEpoch : expiredWith;\n\n            (couponsToPay, couponsToRefund) = oldPosition.calculateCouponRequirement(_positionMap[positionId]);\n        }\n\n        unchecked {\n            for (uint256 i = 0; i < couponsToRefund.length; ++i) {\n                _accountDelta(couponsToRefund[i].id(), 0, couponsToRefund[i].amount);\n            }\n            for (uint256 i = 0; i < couponsToPay.length; ++i) {\n                _accountDelta(couponsToPay[i].id(), couponsToPay[i].amount, 0);\n            }\n            collateralDelta = _accountDelta(\n                uint256(uint160(oldPosition.collateralToken)), collateralAmount, oldPosition.collateralAmount\n            );\n            debtDelta = -_accountDelta(uint256(uint160(oldPosition.debtToken)), oldPosition.debtAmount, debtAmount);\n        }\n    }\n\n    function settlePosition(uint256 positionId) public override(IPositionManager, PositionManager) onlyByLocker {\n        super.settlePosition(positionId);\n        LoanPosition memory position = _positionMap[positionId];\n\n        if (position.debtAmount > 0 && position.expiredWith <= EpochLibrary.lastExpiredEpoch()) {\n            revert UnpaidDebt();\n        }\n\n        LoanConfiguration memory loanConfig =\n            _loanConfiguration[_buildLoanPairId(position.collateralToken, position.debtToken)];\n        (\n            uint256 collateralPriceWithPrecisionComplement,\n            uint256 debtPriceWithPrecisionComplement,\n            uint256 minDebtAmount\n        ) = _calculatePricesAndMinDebtAmount(position.collateralToken, position.debtToken, loanConfig);\n\n        if (position.debtAmount > 0 && minDebtAmount > position.debtAmount) revert TooSmallDebt();\n        if (\n            (position.collateralAmount * collateralPriceWithPrecisionComplement) * loanConfig.liquidationThreshold\n                < position.debtAmount * debtPriceWithPrecisionComplement * _RATE_PRECISION\n        ) revert LiquidationThreshold();\n\n        if (position.debtAmount == 0 && position.collateralAmount == 0) {\n            _burn(positionId);\n        }\n\n        emit PositionUpdated(positionId, position.collateralAmount, position.debtAmount, position.expiredWith);\n    }\n\n    function _buildLoanPairId(address collateral, address debt) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(collateral, debt));\n    }\n\n    function _calculatePricesAndMinDebtAmount(address collateral, address debt, LoanConfiguration memory loanConfig)\n        private\n        view\n        returns (\n            uint256 collateralPriceWithPrecisionComplement,\n            uint256 debtPriceWithPrecisionComplement,\n            uint256 minDebtAmount\n        )\n    {\n        unchecked {\n            uint256 collateralDecimal = loanConfig.collateralDecimal;\n            uint256 debtDecimal = loanConfig.debtDecimal;\n\n            address[] memory assets = new address[](3);\n            assets[0] = collateral;\n            assets[1] = debt;\n            assets[2] = address(0);\n\n            uint256[] memory prices = ICouponOracle(oracle).getAssetsPrices(assets);\n            // @dev `decimal` is always less than or equal to 18\n            minDebtAmount = (minDebtValueInEth * prices[2]) / 10 ** (18 - debtDecimal) / prices[1];\n            if (debtDecimal > collateralDecimal) {\n                collateralPriceWithPrecisionComplement = prices[0] * 10 ** (debtDecimal - collateralDecimal);\n                debtPriceWithPrecisionComplement = prices[1];\n            } else {\n                collateralPriceWithPrecisionComplement = prices[0];\n                debtPriceWithPrecisionComplement = prices[1] * 10 ** (collateralDecimal - debtDecimal);\n            }\n        }\n    }\n\n    function _getLiquidationAmount(LoanPosition memory position, uint256 maxRepayAmount)\n        private\n        view\n        returns (uint256 liquidationAmount, uint256 repayAmount, uint256 protocolFeeAmount)\n    {\n        unchecked {\n            LoanConfiguration memory loanConfig =\n                _loanConfiguration[_buildLoanPairId(position.collateralToken, position.debtToken)];\n            (\n                uint256 collateralPriceWithPrecisionComplement,\n                uint256 debtPriceWithPrecisionComplement,\n                uint256 minDebtAmount\n            ) = _calculatePricesAndMinDebtAmount(position.collateralToken, position.debtToken, loanConfig);\n\n            if (position.expiredWith.isExpired()) {\n                if (maxRepayAmount >= position.debtAmount) {\n                    repayAmount = position.debtAmount;\n                } else if (maxRepayAmount + minDebtAmount > position.debtAmount) {\n                    if (position.debtAmount < minDebtAmount) revert TooSmallDebt();\n                    repayAmount = position.debtAmount - minDebtAmount;\n                } else {\n                    repayAmount = maxRepayAmount;\n                }\n\n                liquidationAmount = Math.ceilDiv(\n                    repayAmount * debtPriceWithPrecisionComplement * _RATE_PRECISION,\n                    collateralPriceWithPrecisionComplement * (_RATE_PRECISION - loanConfig.liquidationFee)\n                );\n            } else {\n                // Every 10^26 of collateralValue >= 1 USD, so it can't overflow.\n                uint256 collateralValue = position.collateralAmount * collateralPriceWithPrecisionComplement;\n                // Every 10^32 of debtValueMulRatePrecision >= 1 USD, so it can't overflow.\n                uint256 debtValueMulRatePrecision =\n                    position.debtAmount * debtPriceWithPrecisionComplement * _RATE_PRECISION;\n\n                if (collateralValue * loanConfig.liquidationThreshold >= debtValueMulRatePrecision) {\n                    return (0, 0, 0);\n                }\n\n                liquidationAmount = Math.ceilDiv(\n                    debtValueMulRatePrecision - collateralValue * loanConfig.liquidationTargetLtv,\n                    collateralPriceWithPrecisionComplement\n                        * (_RATE_PRECISION - loanConfig.liquidationFee - loanConfig.liquidationTargetLtv)\n                );\n                repayAmount = (\n                    liquidationAmount * collateralPriceWithPrecisionComplement\n                        * (_RATE_PRECISION - loanConfig.liquidationFee)\n                ) / debtPriceWithPrecisionComplement / _RATE_PRECISION;\n\n                // reuse newRepayAmount\n                uint256 newRepayAmount = position.debtAmount;\n\n                if (newRepayAmount <= minDebtAmount) {\n                    if (maxRepayAmount < newRepayAmount) revert TooSmallDebt();\n                } else if (repayAmount > newRepayAmount || newRepayAmount < minDebtAmount + repayAmount) {\n                    if (maxRepayAmount < newRepayAmount) {\n                        newRepayAmount = Math.min(maxRepayAmount, newRepayAmount - minDebtAmount);\n                    }\n                } else {\n                    newRepayAmount = Math.min(maxRepayAmount, repayAmount);\n                }\n\n                if (newRepayAmount != repayAmount) {\n                    liquidationAmount = Math.ceilDiv(\n                        newRepayAmount * debtPriceWithPrecisionComplement * _RATE_PRECISION,\n                        collateralPriceWithPrecisionComplement * (_RATE_PRECISION - loanConfig.liquidationFee)\n                    );\n                    repayAmount = newRepayAmount;\n                }\n\n                if (liquidationAmount > position.collateralAmount) liquidationAmount = position.collateralAmount;\n            }\n            protocolFeeAmount = (liquidationAmount * loanConfig.liquidationProtocolFee) / _RATE_PRECISION;\n        }\n    }\n\n    function getLiquidationStatus(uint256 positionId, uint256 maxRepayAmount)\n        external\n        view\n        returns (uint256, uint256, uint256)\n    {\n        return _getLiquidationAmount(_positionMap[positionId], maxRepayAmount > 0 ? maxRepayAmount : type(uint256).max);\n    }\n\n    // @dev We don't have to check the settlement of the position\n    function liquidate(uint256 positionId, uint256 maxRepayAmount)\n        external\n        onlyByLocker\n        returns (uint256 liquidationAmount, uint256 repayAmount, uint256 protocolFeeAmount)\n    {\n        if (!_isSettled(positionId)) revert NotSettled();\n        unchecked {\n            LoanPosition memory position = _positionMap[positionId];\n            (liquidationAmount, repayAmount, protocolFeeAmount) =\n                _getLiquidationAmount(position, maxRepayAmount > 0 ? maxRepayAmount : type(uint256).max);\n\n            if (liquidationAmount == 0 && repayAmount == 0) revert UnableToLiquidate();\n\n            Epoch currentEpoch = EpochLibrary.current();\n            uint256 validEpochLength;\n            if (position.expiredWith >= currentEpoch) {\n                validEpochLength = position.expiredWith.sub(currentEpoch) + 1;\n            }\n\n            position.collateralAmount -= liquidationAmount;\n            position.debtAmount -= repayAmount;\n            if (position.debtAmount == 0) {\n                position.expiredWith = currentEpoch.sub(1);\n                _positionMap[positionId].expiredWith = position.expiredWith;\n            }\n            _positionMap[positionId].collateralAmount = position.collateralAmount;\n            _positionMap[positionId].debtAmount = position.debtAmount;\n\n            _accountDelta(uint256(uint160(position.collateralToken)), protocolFeeAmount, liquidationAmount);\n            IAssetPool(assetPool).withdraw(position.collateralToken, protocolFeeAmount, treasury);\n            _accountDelta(uint256(uint160(position.debtToken)), repayAmount, 0);\n\n            if (validEpochLength > 0) {\n                address couponOwner = ownerOf(positionId);\n                Coupon[] memory coupons = new Coupon[](validEpochLength);\n                for (uint256 i = 0; i < validEpochLength; ++i) {\n                    coupons[i] = CouponLibrary.from(position.debtToken, currentEpoch.add(uint8(i)), repayAmount);\n                }\n                try ICouponManager(_couponManager).mintBatch(couponOwner, coupons, \"\") {}\n                catch {\n                    for (uint256 i = 0; i < validEpochLength; ++i) {\n                        _couponOwed[couponOwner][coupons[i].id()] += coupons[i].amount;\n                    }\n                }\n            }\n\n            emit PositionLiquidated(positionId);\n            emit PositionUpdated(positionId, position.collateralAmount, position.debtAmount, position.expiredWith);\n        }\n    }\n\n    function claimOwedCoupons(CouponKey[] calldata couponKeys, bytes calldata data) external {\n        unchecked {\n            Coupon[] memory coupons = new Coupon[](couponKeys.length);\n            for (uint256 i = 0; i < couponKeys.length; ++i) {\n                uint256 id = couponKeys[i].toId();\n                coupons[i] = Coupon(couponKeys[i], _couponOwed[msg.sender][id]);\n                _couponOwed[msg.sender][id] = 0;\n            }\n            ICouponManager(_couponManager).mintBatch(msg.sender, coupons, data);\n        }\n    }\n\n    function setLoanConfiguration(\n        address collateral,\n        address debt,\n        uint32 liquidationThreshold,\n        uint32 liquidationFee,\n        uint32 liquidationProtocolFee,\n        uint32 liquidationTargetLtv\n    ) external onlyOwner {\n        bytes32 pairId = _buildLoanPairId(collateral, debt);\n        if (_loanConfiguration[pairId].liquidationThreshold > 0) revert InvalidPair();\n        _loanConfiguration[pairId] = LoanConfiguration({\n            collateralDecimal: IERC20Metadata(collateral).decimals(),\n            debtDecimal: IERC20Metadata(debt).decimals(),\n            liquidationThreshold: liquidationThreshold,\n            liquidationFee: liquidationFee,\n            liquidationProtocolFee: liquidationProtocolFee,\n            liquidationTargetLtv: liquidationTargetLtv\n        });\n    }\n\n    function nonces(uint256 positionId) external view returns (uint256) {\n        return _positionMap[positionId].nonce;\n    }\n\n    function _getAndIncrementNonce(uint256 positionId) internal override returns (uint256) {\n        return _positionMap[positionId].getAndIncrementNonce();\n    }\n\n    function _isPairUnregistered(address collateral, address debt) internal view returns (bool) {\n        return _loanConfiguration[_buildLoanPairId(collateral, debt)].liquidationThreshold == 0;\n    }\n\n    function _isSettled(uint256 positionId) internal view override returns (bool) {\n        return _positionMap[positionId].isSettled;\n    }\n\n    function _setPositionSettlement(uint256 positionId, bool settled) internal override {\n        _positionMap[positionId].isSettled = settled;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}